var documenterSearchIndex = {"docs":
[{"location":"formulations/","page":"Formulations","title":"Formulations","text":"CurrentModule = FiniteElementContainers","category":"page"},{"location":"formulations/#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"formulations/","page":"Formulations","title":"Formulations","text":"AbstractMechanicsFormulation","category":"page"},{"location":"formulations/#FiniteElementContainers.AbstractMechanicsFormulation","page":"Formulations","title":"FiniteElementContainers.AbstractMechanicsFormulation","text":"abstract type AbstractMechanicsFormulation{ND}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#Implementations","page":"Formulations","title":"Implementations","text":"","category":"section"},{"location":"formulations/","page":"Formulations","title":"Formulations","text":"IncompressiblePlaneStress","category":"page"},{"location":"formulations/#FiniteElementContainers.IncompressiblePlaneStress","page":"Formulations","title":"FiniteElementContainers.IncompressiblePlaneStress","text":"struct IncompressiblePlaneStress <: AbstractMechanicsFormulation{2}\n\n\n\n\n\n","category":"type"},{"location":"formulations/","page":"Formulations","title":"Formulations","text":"PlaneStrain","category":"page"},{"location":"formulations/#FiniteElementContainers.PlaneStrain","page":"Formulations","title":"FiniteElementContainers.PlaneStrain","text":"struct PlaneStrain <: AbstractMechanicsFormulation{2}\n\n\n\n\n\n","category":"type"},{"location":"formulations/","page":"Formulations","title":"Formulations","text":"ScalarFormulation","category":"page"},{"location":"formulations/#FiniteElementContainers.ScalarFormulation","page":"Formulations","title":"FiniteElementContainers.ScalarFormulation","text":"struct ScalarFormulation <: AbstractMechanicsFormulation{1}\n\n\n\n\n\n","category":"type"},{"location":"formulations/","page":"Formulations","title":"Formulations","text":"ThreeDimensional","category":"page"},{"location":"formulations/#FiniteElementContainers.ThreeDimensional","page":"Formulations","title":"FiniteElementContainers.ThreeDimensional","text":"struct ThreeDimensional <: AbstractMechanicsFormulation{3}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#Methods","page":"Formulations","title":"Methods","text":"","category":"section"},{"location":"formulations/","page":"Formulations","title":"Formulations","text":"discrete_gradient\ndiscrete_symmetric_gradient\ndiscrete_values\nextract_stiffness\nextract_stress\nmodify_field_gradients\nnum_dimensions","category":"page"},{"location":"formulations/#FiniteElementContainers.discrete_gradient","page":"Formulations","title":"FiniteElementContainers.discrete_gradient","text":"discrete_gradient(_::IncompressiblePlaneStress, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::PlaneStrain, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::ScalarFormulation, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::ThreeDimensional, ∇N_X) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.discrete_symmetric_gradient","page":"Formulations","title":"FiniteElementContainers.discrete_symmetric_gradient","text":"discrete_symmetric_gradient(\n    _::IncompressiblePlaneStress,\n    ∇N_X\n) -> Any\n\n\n\n\n\n\ndiscrete_symmetric_gradient(_::PlaneStrain, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_symmetric_gradient(_::ScalarFormulation, ∇N_X)\n\n\n\n\n\n\ndiscrete_symmetric_gradient(\n    _::ThreeDimensional,\n    ∇N_X\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.discrete_values","page":"Formulations","title":"FiniteElementContainers.discrete_values","text":"discrete_values(_::IncompressiblePlaneStress, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::PlaneStrain, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::ScalarFormulation, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::ThreeDimensional, N) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.extract_stiffness","page":"Formulations","title":"FiniteElementContainers.extract_stiffness","text":"extract_stiffness(\n    _::IncompressiblePlaneStress,\n    A::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stiffness(\n    _::PlaneStrain,\n    A::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stiffness(\n    _::ThreeDimensional,\n    A_in::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.extract_stress","page":"Formulations","title":"FiniteElementContainers.extract_stress","text":"extract_stress(\n    _::IncompressiblePlaneStress,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stress(\n    _::PlaneStrain,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stress(\n    _::ThreeDimensional,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.modify_field_gradients","page":"Formulations","title":"FiniteElementContainers.modify_field_gradients","text":"modify_field_gradients(\n    _::IncompressiblePlaneStress,\n    ∇u_q::StaticArraysCore.SArray{Tuple{2, 2}, T<:Number, 2, 4}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\nmodify_field_gradients(\n    _::PlaneStrain,\n    ∇u_q::StaticArraysCore.SArray{Tuple{2, 2}, T<:Number, 2, 4}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\nmodify_field_gradients(\n    _::ThreeDimensional,\n    ∇u_q::StaticArraysCore.SArray{Tuple{3, 3}, T<:Number, 2, 9}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.num_dimensions","page":"Formulations","title":"FiniteElementContainers.num_dimensions","text":"num_dimensions(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\nnum_dimensions(_::AbstractMechanicsFormulation{ND}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"function_spaces/#FunctionSpace","page":"Function spaces","title":"FunctionSpace","text":"","category":"section"},{"location":"function_spaces/","page":"Function spaces","title":"Function spaces","text":"using Exodus, FiniteElementContainers\nmesh = UnstructuredMesh(\"../../test/poisson/poisson.g\")\nV = FunctionSpace(mesh, H1Field, Lagrange)","category":"page"},{"location":"function_spaces/#API","page":"Function spaces","title":"API","text":"","category":"section"},{"location":"function_spaces/","page":"Function spaces","title":"Function spaces","text":"Modules = [FiniteElementContainers]\nPages = [\"FunctionSpaces.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"function_spaces/#FiniteElementContainers.AbstractFunctionSpace","page":"Function spaces","title":"FiniteElementContainers.AbstractFunctionSpace","text":"abstract type AbstractFunctionSpace\n\n\n\n\n\n","category":"type"},{"location":"function_spaces/#FiniteElementContainers.FunctionSpace","page":"Function spaces","title":"FiniteElementContainers.FunctionSpace","text":"struct FunctionSpace{Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides} <: FiniteElementContainers.AbstractFunctionSpace\n\ncoords::Any\nelem_conns::Any\nelem_id_maps::Any\nref_fes::Any\nsideset_elems::Any\nsideset_nodes::Any\nsideset_sides::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"AbstractFunctions are used to represent elements of FunctionSpaces.","category":"page"},{"location":"functions/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [FiniteElementContainers]\nPages = [\"Functions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"functions/#FiniteElementContainers.AbstractFunction","page":"Functions","title":"FiniteElementContainers.AbstractFunction","text":"abstract type AbstractFunction{S, F<:FunctionSpace}\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.ScalarFunction","page":"Functions","title":"FiniteElementContainers.ScalarFunction","text":"struct ScalarFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.ScalarFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.ScalarFunction","text":"ScalarFunction(\n    fspace::FunctionSpace,\n    sym\n) -> ScalarFunction{_A, FunctionSpace{Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}} where {_A, Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.StateFunction-Tuple{FunctionSpace, Any, Any, Any}","page":"Functions","title":"FiniteElementContainers.StateFunction","text":"StateFunction(\n    fspace::FunctionSpace,\n    sym,\n    n_state,\n    n_quad_pts\n) -> StateFunction{_A, FunctionSpace{Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}} where {_A, Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.SymmetricTensorFunction","page":"Functions","title":"FiniteElementContainers.SymmetricTensorFunction","text":"struct SymmetricTensorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.SymmetricTensorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.SymmetricTensorFunction","text":"SymmetricTensorFunction(\n    fspace::FunctionSpace,\n    sym;\n    use_spatial_dimension\n) -> SymmetricTensorFunction{_A, FunctionSpace{Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}} where {_A, Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}\n\n\nUses numbering consistent with exodus output, is this the right thing to do? Should it be consistent with Tensors.jl\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.TensorFunction","page":"Functions","title":"FiniteElementContainers.TensorFunction","text":"struct TensorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.TensorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.TensorFunction","text":"TensorFunction(\n    fspace::FunctionSpace,\n    sym;\n    use_spatial_dimension\n) -> TensorFunction{_A, FunctionSpace{Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}} where {_A, Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.VectorFunction","page":"Functions","title":"FiniteElementContainers.VectorFunction","text":"struct VectorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.VectorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.VectorFunction","text":"VectorFunction(\n    fspace::FunctionSpace,\n    sym\n) -> VectorFunction{_A, FunctionSpace{Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}} where {_A, Coords, ElemConns, ElemIdMaps, RefFEs, SSetElems, SSetNodes, SSetSides}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.length-Union{Tuple{FiniteElementContainers.AbstractFunction{S, F}}, Tuple{F}, Tuple{S}} where {S, F}","page":"Functions","title":"Base.length","text":"length(\n    _::FiniteElementContainers.AbstractFunction{S, F}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.names-Union{Tuple{FiniteElementContainers.AbstractFunction{S, F}}, Tuple{F}, Tuple{S}} where {S, F}","page":"Functions","title":"Base.names","text":"names(\n    _::FiniteElementContainers.AbstractFunction{S, F}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"CurrentModule = FiniteElementContainers","category":"page"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Meshes in FiniteElementContainers leverage a very abstract interface. No single mesh format is directly supported in the main src code but rather different mesh types are relegated to package extensions. Currently, only an Exodus package extension is supported but others could be readily supported.","category":"page"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Modules = [FiniteElementContainers]\nPages = [\"Meshes.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"meshes/#FiniteElementContainers.AbstractMesh","page":"Meshes","title":"FiniteElementContainers.AbstractMesh","text":"abstract type AbstractMesh <: FiniteElementContainers.FEMContainer\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.FileMesh","page":"Meshes","title":"FiniteElementContainers.FileMesh","text":"struct FileMesh{MeshObj} <: FiniteElementContainers.AbstractMesh\n\nfile_name::String\nmesh_obj::Any\n\nMesh type that has a handle to an open mesh file object. This type's methods are \"overridden\" in extensions.\n\nSee FiniteElementContainersExodusExt for an example.\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"struct UnstructuredMesh{MeshObj, X, EBlockNames, ETypes, EConns, EMaps, NSetNodes, SSetElems, SSetNodes, SSetSides, EdgeConns, FaceConns} <: FiniteElementContainers.AbstractMesh\n\nmesh_obj::Any\nnodal_coords::Any\nelement_block_names::Any\nelement_types::Any\nelement_conns::Any\nelement_id_maps::Any\nnodeset_nodes::Any\nsideset_elems::Any\nsideset_nodes::Any\nsideset_sides::Any\nedge_conns::Any\nface_conns::Any\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Tuple{Any, String, Bool, Bool}","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file_type,\n    file_name::String,\n    create_edges::Bool,\n    create_faces::Bool\n)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Tuple{String}","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file_name::String;\n    create_edges,\n    create_faces\n)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.coordinates-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.coordinates","text":"coordinates(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.copy_mesh","page":"Meshes","title":"FiniteElementContainers.copy_mesh","text":"Dummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"function"},{"location":"meshes/#FiniteElementContainers.element_block_id_map-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.element_block_id_map","text":"element_block_id_map(\n    _::FiniteElementContainers.AbstractMesh,\n    id\n)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_ids-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.element_block_ids","text":"element_block_ids(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_names-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.element_block_names","text":"element_block_names(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_connectivity-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.element_connectivity","text":"element_connectivity(\n    _::FiniteElementContainers.AbstractMesh\n)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_type-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.element_type","text":"element_type(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.file_name-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.file_name","text":"file_name(mesh::FiniteElementContainers.AbstractMesh) -> Any\n\n\nReturns file name for an mesh type\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.nodeset","text":"nodeset(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset_ids-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.nodeset_ids","text":"nodeset_ids(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset_names-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.nodeset_names","text":"nodeset_names(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodesets-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.nodesets","text":"nodesets(_::FiniteElementContainers.AbstractMesh, ids)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.num_dimensions-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.num_dimensions","text":"num_dimensions(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.num_nodes-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.num_nodes","text":"num_nodes(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.sideset","text":"sideset(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset_ids-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.sideset_ids","text":"sideset_ids(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset_names-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.sideset_names","text":"sideset_names(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sidesets-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.sidesets","text":"sidesets(_::FiniteElementContainers.AbstractMesh, ids)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"CurrentModule = FiniteElementContainers","category":"page"},{"location":"assemblers/#Assemblers","page":"Assemblers","title":"Assemblers","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"This section describes the assemblers that are currently available and their abstract interface.","category":"page"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"All assemblers must possess at minimum a DofManager.","category":"page"},{"location":"assemblers/#Abstract-Interface","page":"Assemblers","title":"Abstract Interface","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"Modules = [FiniteElementContainers]\nPages = [\"Assemblers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"assemblers/#FiniteElementContainers.AbstractAssembler","page":"Assemblers","title":"FiniteElementContainers.AbstractAssembler","text":"abstract type AbstractAssembler{Dof<:DofManager}\n\n\n\n\n\n","category":"type"},{"location":"assemblers/#FiniteElementContainers._assemble_element!-Tuple{H1Field, Vararg{Any, 4}}","page":"Assemblers","title":"FiniteElementContainers._assemble_element!","text":"_assemble_element!(\n    global_val::H1Field,\n    local_val,\n    conn,\n    e,\n    b\n)\n\n\nAssembly method for an H1Field, e.g. internal force Called on a single element e for a given block b where local_val has already been constructed from quadrature contributions.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_element!-Union{Tuple{T}, Tuple{T, Vararg{Any, 4}}} where T<:(AbstractVector{<:Number})","page":"Assemblers","title":"FiniteElementContainers._assemble_element!","text":"_assemble_element!(\n    global_val::AbstractVector{<:Number},\n    local_val,\n    conn,\n    e,\n    b\n)\n\n\nAssembly method for a scalar field stored as a size 1 vector Called on a single element e for a given block b where local_val has already been constructed from quadrature contributions.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_coordinates-Tuple{H1Field, Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_level_coordinates","text":"_element_level_coordinates(\n    X::H1Field,\n    ref_fe,\n    conns,\n    e\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_fields-Tuple{H1Field, Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_level_fields","text":"_element_level_fields(U::H1Field, ref_fe, conns, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._zero_storage-Tuple{FiniteElementContainers.AbstractAssembler, Val{:residual}}","page":"Assemblers","title":"FiniteElementContainers._zero_storage","text":"_zero_storage(\n    asm::FiniteElementContainers.AbstractAssembler,\n    _::Val{:residual}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble!-Tuple{Any, Any, H1Field, Any}","page":"Assemblers","title":"FiniteElementContainers.assemble!","text":"assemble!(assembler, physics, U::H1Field, sym)\n\n\nTop level assembly method for H1Field that loops over blocks and dispatches to appropriate kernels based on sym.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.create_bcs-Tuple{FiniteElementContainers.AbstractAssembler, Any}","page":"Assemblers","title":"FiniteElementContainers.create_bcs","text":"create_bcs(\n    asm::FiniteElementContainers.AbstractAssembler,\n    type\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.create_field-Tuple{FiniteElementContainers.AbstractAssembler, Any}","page":"Assemblers","title":"FiniteElementContainers.create_field","text":"create_field(\n    asm::FiniteElementContainers.AbstractAssembler,\n    type\n) -> Union{Nothing, H1Field{Float64, _A, Vector{Float64}} where _A}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.create_unknowns-Tuple{FiniteElementContainers.AbstractAssembler, Type{<:FiniteElementContainers.AbstractField}}","page":"Assemblers","title":"FiniteElementContainers.create_unknowns","text":"create_unknowns(\n    asm::FiniteElementContainers.AbstractAssembler,\n    type::Type{<:FiniteElementContainers.AbstractField}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.create_unknowns-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.create_unknowns","text":"create_unknowns(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.residual-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.residual","text":"residual(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.update_field!-Tuple{Any, FiniteElementContainers.AbstractAssembler, Any, Any}","page":"Assemblers","title":"FiniteElementContainers.update_field!","text":"update_field!(\n    U,\n    asm::FiniteElementContainers.AbstractAssembler,\n    Uu,\n    Ubc\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"KernelAbstractions.get_backend","text":"get_backend(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Abstract-Interface-CPU-Specialization","page":"Assemblers","title":"Abstract Interface - CPU Specialization","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"Modules = [FiniteElementContainers]\nPages = [\"CPUGeneral.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"assemblers/#FiniteElementContainers._assemble_block_residual!-Tuple{Any, Any, Any, Any, Any, Any, Any, KernelAbstractions.CPU}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_residual!","text":"_assemble_block_residual!(\n    assembler,\n    physics,\n    ref_fe,\n    U,\n    X,\n    conns,\n    block_id,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO add state variables and physics properties TODO remove Float64 typing below for eventual unitful use\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._residual-Tuple{FiniteElementContainers.AbstractAssembler, KernelAbstractions.CPU}","page":"Assemblers","title":"FiniteElementContainers._residual","text":"_residual(\n    asm::FiniteElementContainers.AbstractAssembler,\n    _::KernelAbstractions.CPU\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Abstract-Interface-GPU-Specialization","page":"Assemblers","title":"Abstract Interface - GPU Specialization","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"Modules = [FiniteElementContainers]\nPages = [\"GPUGeneral.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"assemblers/#FiniteElementContainers._assemble_block_residual!-Tuple{Any, Any, Any, Any, Any, Any, Any, KernelAbstractions.Backend}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_residual!","text":"_assemble_block_residual!(\n    assembler,\n    physics,\n    ref_fe,\n    U,\n    X,\n    conns,\n    block_id,\n    backend::KernelAbstractions.Backend\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_residual_kernel!-Tuple{Any}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_residual_kernel!","text":"_assemble_block_residual_kernel!(\n    dev\n) -> Union{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.DynamicSize, KernelAbstractions.NDIteration.DynamicSize, typeof(FiniteElementContainers.cpu__assemble_block_residual_kernel!)}, KernelAbstractions.Kernel{Backend, KernelAbstractions.NDIteration.DynamicSize, KernelAbstractions.NDIteration.DynamicSize, typeof(FiniteElementContainers.gpu__assemble_block_residual_kernel!)} where Backend<:KernelAbstractions.GPU}\n\n\nKernel for residual block assembly\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_stiffness!-Tuple{Any, Any, Any, Any, Any, Any, Any, KernelAbstractions.Backend}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_stiffness!","text":"_assemble_block_stiffness!(\n    assembler,\n    physics,\n    ref_fe,\n    U,\n    X,\n    conns,\n    block_id,\n    backend::KernelAbstractions.Backend\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._extract_residual_unknowns!-Tuple{Any}","page":"Assemblers","title":"FiniteElementContainers._extract_residual_unknowns!","text":"_extract_residual_unknowns!(\n    dev\n) -> Union{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.DynamicSize, KernelAbstractions.NDIteration.DynamicSize, typeof(FiniteElementContainers.cpu__extract_residual_unknowns!)}, KernelAbstractions.Kernel{Backend, KernelAbstractions.NDIteration.DynamicSize, KernelAbstractions.NDIteration.DynamicSize, typeof(FiniteElementContainers.gpu__extract_residual_unknowns!)} where Backend<:KernelAbstractions.GPU}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._residual-Tuple{FiniteElementContainers.AbstractAssembler, KernelAbstractions.Backend}","page":"Assemblers","title":"FiniteElementContainers._residual","text":"_residual(\n    asm::FiniteElementContainers.AbstractAssembler,\n    backend::KernelAbstractions.Backend\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#SparsityPattern","page":"Assemblers","title":"SparsityPattern","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"Modules = [FiniteElementContainers]\nPages = [\"SparsityPattern.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"assemblers/#FiniteElementContainers.SparsityPattern","page":"Assemblers","title":"FiniteElementContainers.SparsityPattern","text":"struct SparsityPattern{I<:AbstractVector{Int64}, B, R<:AbstractVector{Float64}}\n\nIs::AbstractVector{Int64}\nJs::AbstractVector{Int64}\nunknown_dofs::AbstractVector{Int64}\nblock_sizes::Any\nblock_offsets::Any\nklasttouch::AbstractVector{Int64}\ncsrrowptr::AbstractVector{Int64}\ncsrcolval::AbstractVector{Int64}\ncsrnzval::AbstractVector{Float64}\ncsccolptr::AbstractVector{Int64}\ncscrowval::AbstractVector{Int64}\ncscnzval::AbstractVector{Float64}\n\nBook-keeping struct for sparse matrices in FEM settings. This has all the information to construct a sparse matrix for either case where you want to eliminate fixed-dofs or not.\n\n\n\n\n\n","category":"type"},{"location":"assemblers/#SparseMatrixAssembler","page":"Assemblers","title":"SparseMatrixAssembler","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"Modules = [FiniteElementContainers]\nPages = [\"SparseMatrixAssembler.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"assemblers/#FiniteElementContainers.SparseMatrixAssembler","page":"Assemblers","title":"FiniteElementContainers.SparseMatrixAssembler","text":"struct SparseMatrixAssembler{Dof<:DofManager, Pattern<:FiniteElementContainers.SparsityPattern, Storage1<:(AbstractArray{<:Number}), Storage2<:FiniteElementContainers.AbstractField, Storage3<:(AbstractVector{<:Number})} <: FiniteElementContainers.AbstractAssembler{Dof<:DofManager}\n\nGeneral sparse matrix assembler that can handle first or second order problems in time. \n\n\n\n\n\n","category":"type"},{"location":"assemblers/#FiniteElementContainers.SparseMatrixAssembler-Tuple{DofManager, Type{<:H1Field}}","page":"Assemblers","title":"FiniteElementContainers.SparseMatrixAssembler","text":"SparseMatrixAssembler(\n    dof::DofManager,\n    type::Type{<:H1Field}\n) -> SparseMatrixAssembler{Dof, Pattern, Vector{Float64}, Storage2} where {Dof<:DofManager, Pattern<:(FiniteElementContainers.SparsityPattern{Vector{Int64}, _A, Vector{Float64}} where _A), Storage2<:(H1Field{Float64, _A, Vector{Float64}} where _A)}\n\n\nConstruct a SparseMatrixAssembler for a specific field type,  e.g. H1Field. Can be used to create block arrays for mixed FEM problems.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_mass!-Tuple{Any, Any, Any, Any, Any, Any, Any, KernelAbstractions.CPU}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_mass!","text":"_assemble_block_mass!(\n    assembler,\n    physics,\n    ref_fe,\n    U,\n    X,\n    conns,\n    block_id,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_residual_and_stiffness!-Tuple{Any, Any, Any, Any, Any, Any, Any, KernelAbstractions.CPU}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_residual_and_stiffness!","text":"_assemble_block_residual_and_stiffness!(\n    assembler,\n    physics,\n    ref_fe,\n    U,\n    X,\n    conns,\n    block_id,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO add state variables and physics properties TODO remove Float64 typing below for eventual unitful use\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_stiffness!-Tuple{Any, Any, Any, Any, Any, Any, Any, KernelAbstractions.CPU}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_stiffness!","text":"_assemble_block_stiffness!(\n    assembler,\n    physics,\n    ref_fe,\n    U,\n    X,\n    conns,\n    block_id,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_element!-Tuple{SparseMatrixAssembler, Any, StaticArraysCore.SMatrix, Any, Int64, Int64}","page":"Assemblers","title":"FiniteElementContainers._assemble_element!","text":"_assemble_element!(\n    asm::SparseMatrixAssembler,\n    sym,\n    K_el::StaticArraysCore.SMatrix,\n    conn,\n    el_id::Int64,\n    block_id::Int64\n)\n\n\nSpecialization of of _assemble_element! for SparseMatrixAssembler.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#SparseArrays.sparse!-Tuple{SparseMatrixAssembler, Any}","page":"Assemblers","title":"SparseArrays.sparse!","text":"sparse!(\n    assembler::SparseMatrixAssembler,\n    sym\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nTODO add symbol to interface\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#SparseArrays.sparse-Tuple{SparseMatrixAssembler}","page":"Assemblers","title":"SparseArrays.sparse","text":"sparse(\n    assembler::SparseMatrixAssembler\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv<:Number\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"CurrentModule = FiniteElementContainers\nDocTestFilters = [\n    r\"{([a-zA-Z0-9]+,\\s?)+[a-zA-Z0-9]+}\",\n    r\"(Array{[a-zA-Z0-9]+,\\s?1}|Vector{[a-zA-Z0-9]+})\",\n    r\"(Array{[a-zA-Z0-9]+,\\s?2}|Matrix{[a-zA-Z0-9]+})\",\n]","category":"page"},{"location":"dof_manager/#DofManager","page":"DofManager","title":"DofManager","text":"","category":"section"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"The DofManager is a struct that keeps track of which dofs are unknown or constrained. This can work with simple or mixed finite element spaces of various types. It is a glorified book keeper.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"A DofManager can be created as follows. First we must create functions for our variables of interest from their associated function spaces.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"using Exodus, FiniteElementContainers\nmesh = UnstructuredMesh(\"../../test/poisson/poisson.g\")\nV = FunctionSpace(mesh, H1Field, Lagrange)\nu = VectorFunction(V, :u)\nt = ScalarFunction(V, :t)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"Now we can supply these variables to the DofManager which takes varargs as inputs","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"dof = DofManager(u, t)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"The print methods for this struct show simple metadata about the current dofs for each possible function space.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"A set of unknowns can be set up as follows","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"field = create_unknowns(dof)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"We can create fields of the right size from the DofManager with the following methods","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"field = create_field(dof, H1Field)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"These methods take the backed of dof into account to ensure that the fields or unknowns produced are on the same device, e.g. CPU/GPU if dof is on the CPU/GPU.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"This struct is created with all dofs initially set as unknown. To modify the unknowns we can do the following","category":"page"},{"location":"dof_manager/#API","page":"DofManager","title":"API","text":"","category":"section"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"Modules = [FiniteElementContainers]\nPages = [\"DofManagers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"dof_manager/#FiniteElementContainers.DofManager","page":"DofManager","title":"FiniteElementContainers.DofManager","text":"struct DofManager{T, IDs<:AbstractArray{T, 1}, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n\nH1_bc_dofs::AbstractVector\nH1_unknown_dofs::AbstractVector\nHcurl_bc_dofs::AbstractVector\nHcurl_unknown_dofs::AbstractVector\nHdiv_bc_dofs::AbstractVector\nHdiv_unknown_dofs::AbstractVector\nL2_element_dofs::AbstractVector\nL2_quadrature_dofs::AbstractVector\nH1_vars::Any\nHcurl_vars::Any\nHdiv_vars::Any\nL2_element_vars::Any\nL2_quadrature_vars::Any\n\n\n\n\n\n","category":"type"},{"location":"dof_manager/#FiniteElementContainers.DofManager-Tuple","page":"DofManager","title":"FiniteElementContainers.DofManager","text":"DofManager(\n    vars...\n) -> DofManager{T, _B, _C, 0, 0, _D, _E, NamedTuple{_A, var\"#s178\"}, @NamedTuple{}, @NamedTuple{}, NamedTuple{_A1, var\"#s1781\"}, NamedTuple{_A2, var\"#s1782\"}} where {T, _B<:AbstractVector{T}, _C, _D, _E, _A, var\"#s178\"<:Tuple, _A1, var\"#s1781\"<:Tuple, _A2, var\"#s1782\"<:Tuple}\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#Base.eltype-Union{Tuple{DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}}, Tuple{L2QVars}, Tuple{L2EVars}, Tuple{HdivVars}, Tuple{HcurlVars}, Tuple{H1Vars}, Tuple{NL2QDofs}, Tuple{NL2EDofs}, Tuple{NHdivDofs}, Tuple{NHcurlDofs}, Tuple{NH1Dofs}, Tuple{IDs}, Tuple{T}} where {T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}","page":"DofManager","title":"Base.eltype","text":"eltype(\n    _::DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#Base.length-Tuple{DofManager}","page":"DofManager","title":"Base.length","text":"length(dof::DofManager) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_bcs-Tuple{DofManager, Type{H1Field}}","page":"DofManager","title":"FiniteElementContainers.create_bcs","text":"create_bcs(dof::DofManager, _::Type{H1Field}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_field-Tuple{DofManager, Type{H1Field}, Any}","page":"DofManager","title":"FiniteElementContainers.create_field","text":"create_field(\n    dof::DofManager,\n    _::Type{H1Field},\n    syms\n) -> H1Field{Float64, _A, Vector{Float64}} where _A\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_field-Tuple{DofManager, Type{H1Field}}","page":"DofManager","title":"FiniteElementContainers.create_field","text":"create_field(\n    dof::DofManager,\n    _::Type{H1Field}\n) -> H1Field{Float64, _A, Vector{Float64}} where _A\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_field-Tuple{DofManager, Type{L2QuadratureField}}","page":"DofManager","title":"FiniteElementContainers.create_field","text":"create_field(dof::DofManager, _::Type{L2QuadratureField})\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_unknowns-Tuple{DofManager}","page":"DofManager","title":"FiniteElementContainers.create_unknowns","text":"create_unknowns(dof::DofManager) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_dofs_per_edge-Union{Tuple{DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}}, Tuple{L2QVars}, Tuple{L2EVars}, Tuple{HdivVars}, Tuple{HcurlVars}, Tuple{H1Vars}, Tuple{NL2QDofs}, Tuple{NL2EDofs}, Tuple{NHdivDofs}, Tuple{NHcurlDofs}, Tuple{NH1Dofs}, Tuple{IDs}, Tuple{T}} where {T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}","page":"DofManager","title":"FiniteElementContainers.num_dofs_per_edge","text":"num_dofs_per_edge(\n    _::DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_dofs_per_element-Union{Tuple{DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}}, Tuple{L2QVars}, Tuple{L2EVars}, Tuple{HdivVars}, Tuple{HcurlVars}, Tuple{H1Vars}, Tuple{NL2QDofs}, Tuple{NL2EDofs}, Tuple{NHdivDofs}, Tuple{NHcurlDofs}, Tuple{NH1Dofs}, Tuple{IDs}, Tuple{T}} where {T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}","page":"DofManager","title":"FiniteElementContainers.num_dofs_per_element","text":"num_dofs_per_element(\n    _::DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_dofs_per_face-Union{Tuple{DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}}, Tuple{L2QVars}, Tuple{L2EVars}, Tuple{HdivVars}, Tuple{HcurlVars}, Tuple{H1Vars}, Tuple{NL2QDofs}, Tuple{NL2EDofs}, Tuple{NHdivDofs}, Tuple{NHcurlDofs}, Tuple{NH1Dofs}, Tuple{IDs}, Tuple{T}} where {T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}","page":"DofManager","title":"FiniteElementContainers.num_dofs_per_face","text":"num_dofs_per_face(\n    _::DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_dofs_per_node-Union{Tuple{DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}}, Tuple{L2QVars}, Tuple{L2EVars}, Tuple{HdivVars}, Tuple{HcurlVars}, Tuple{H1Vars}, Tuple{NL2QDofs}, Tuple{NL2EDofs}, Tuple{NHdivDofs}, Tuple{NHcurlDofs}, Tuple{NH1Dofs}, Tuple{IDs}, Tuple{T}} where {T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}","page":"DofManager","title":"FiniteElementContainers.num_dofs_per_node","text":"num_dofs_per_node(\n    _::DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_dofs_per_quadrature_point-Union{Tuple{DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}}, Tuple{L2QVars}, Tuple{L2EVars}, Tuple{HdivVars}, Tuple{HcurlVars}, Tuple{H1Vars}, Tuple{NL2QDofs}, Tuple{NL2EDofs}, Tuple{NHdivDofs}, Tuple{NHcurlDofs}, Tuple{NH1Dofs}, Tuple{IDs}, Tuple{T}} where {T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}","page":"DofManager","title":"FiniteElementContainers.num_dofs_per_quadrature_point","text":"num_dofs_per_quadrature_point(\n    _::DofManager{T, IDs, NH1Dofs, NHcurlDofs, NHdivDofs, NL2EDofs, NL2QDofs, H1Vars, HcurlVars, HdivVars, L2EVars, L2QVars}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_edges-Tuple{DofManager}","page":"DofManager","title":"FiniteElementContainers.num_edges","text":"num_edges(dof::DofManager) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_faces-Tuple{DofManager}","page":"DofManager","title":"FiniteElementContainers.num_faces","text":"num_faces(dof::DofManager) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.num_unknowns-Tuple{DofManager}","page":"DofManager","title":"FiniteElementContainers.num_unknowns","text":"num_unknowns(dof::DofManager) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_dofs!-Union{Tuple{T}, Tuple{DofManager, T}} where T<:(AbstractVector{<:Integer})","page":"DofManager","title":"FiniteElementContainers.update_dofs!","text":"update_dofs!(\n    dof::DofManager,\n    dirichlet_dofs::AbstractVector{<:Integer}\n)\n\n\nCurrently not GPU compatable.\n\nThis is only an issue if dofs that correspond to Dirichlet BCs will change often. Otherwise, setup can be achieved on the CPU and transferred to the GPU.\n\nTODO this method need to look at the dirichlet dofs to see what type of variable is there. That way the  appropriate function space book keepers can be updated. Currently this only works with H1 spaces.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_field!-Union{Tuple{T}, Tuple{H1Field, DofManager, T, T}} where T<:(AbstractVector{<:Number})","page":"DofManager","title":"FiniteElementContainers.update_field!","text":"update_field!(\n    U::H1Field,\n    dof::DofManager,\n    Uu::AbstractVector{<:Number},\n    Ubc::AbstractVector{<:Number}\n)\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_field_bcs!-Union{Tuple{T}, Tuple{H1Field, DofManager, T}} where T<:(AbstractVector{<:Number})","page":"DofManager","title":"FiniteElementContainers.update_field_bcs!","text":"update_field_bcs!(\n    U::H1Field,\n    dof::DofManager,\n    Ubc::AbstractVector{<:Number}\n)\n\n\nDoes a simple copy on CPUs. On GPUs it uses a KernelAbstractions kernel\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_field_unknowns!-Union{Tuple{T}, Tuple{H1Field, DofManager, T, typeof(+)}} where T<:(AbstractVector{<:Number})","page":"DofManager","title":"FiniteElementContainers.update_field_unknowns!","text":"update_field_unknowns!(\n    U::H1Field,\n    dof::DofManager,\n    Uu::AbstractVector{<:Number},\n    _::typeof(+)\n)\n\n\nDoes a simple addition on CPUs. On GPUs it uses a KernelAbstractions kernel\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_field_unknowns!-Union{Tuple{T}, Tuple{H1Field, DofManager, T}} where T<:(AbstractVector{<:Number})","page":"DofManager","title":"FiniteElementContainers.update_field_unknowns!","text":"update_field_unknowns!(\n    U::H1Field,\n    dof::DofManager,\n    Uu::AbstractVector{<:Number}\n)\n\n\nDoes a simple copy on CPUs. On GPUs it uses a KernelAbstractions kernel\n\n\n\n\n\n","category":"method"},{"location":"physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FiniteElementContainers","category":"page"},{"location":"#FiniteElementContainers","page":"Home","title":"FiniteElementContainers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FiniteElementContainers.jl is a package whose main purpose is to help  researchers develop new finite element method (FEM) applications for both well known existing techniques and new novel strategies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is specificially designed with the challenging aspects of computational solid mechanics in mind where meshes deform, there's path dependence, there's contact between bodies, there are potentially heterogeneous material properties, and other challenges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're primarily interested in writing FEM applications for e.g. the Poisson equation or heat equation, there's likely more efficient packages (e.g. Gridap or Ferrite) out there for this purpose in terms of memory and computational efficiency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, if you need to solve problems with multiple material models, meshes where there are mixed elements types, etc. this is likely the only julia package at the time of writing this that supports such capabilities. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inspiration for the software design primarily comes from fenics and MOOSE. We've specifically designed the interface to get around all the shortcomings of fenics  (e.g. boundary conditions are a pain, mixed element types a plain, different blocks are pain etc.) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our goal is also to ensure all of our methods are next generation hardware capable. This means not only supporting things on CPUs but also GPUs (and that doesn't just mean NVIDIA).","category":"page"},{"location":"boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This section describes the user facing API for boundary conditions along with the implementation details.","category":"page"},{"location":"boundary_conditions/#DirichletBC","page":"Boundary Conditions","title":"DirichletBC","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We can set up dirichlet boundary conditions on a variable u and sideset sset_1 with a zero function as follows.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using FiniteElementContainers\nbc_func(x, t) = 0.\nbc = DirichletBC(:u, :sset_1, bc_func)","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Internally this is eventually converted in a DirichletBCContainer","category":"page"},{"location":"boundary_conditions/#API","page":"Boundary Conditions","title":"API","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Modules = [FiniteElementContainers]\nPages = [\"DirichletBCs.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\nUser facing API to define a DirichletBC`.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC-Tuple{Symbol, Symbol, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nDirichletBC(\n    var_name::Symbol,\n    sset_name::Symbol,\n    func::Function\n) -> DirichletBC{<:Function}\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBCContainer","text":"struct DirichletBCContainer{B, F, V} <: FiniteElementContainers.AbstractBCContainer{B, F, V}\n\nbookkeeping::Any\nfunc::Any\nvals::Any\n\nInternal implementation of dirichlet BCs\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#Boundary-Condition-Implementation-Details","page":"Boundary Conditions","title":"Boundary Condition Implementation Details","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Modules = [FiniteElementContainers]\nPages = [\"BoundaryConditions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBC","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBC","text":"abstract type AbstractBC{F<:Function}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBC-Tuple{Any, Any}","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBC","text":"\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBCContainer","text":"abstract type AbstractBCContainer{B<:FiniteElementContainers.BCBookKeeping, F<:Function, V<:(AbstractVector{<:Number})}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"struct BCBookKeeping{V<:(AbstractVector{<:Integer})}\n\nblocks::AbstractVector{<:Integer}\ndofs::AbstractVector{<:Integer}\nelements::AbstractVector{<:Integer}\nnodes::AbstractVector{<:Integer}\nsides::AbstractVector{<:Integer}\n\nThis struct is used to help with book keeping nodes, sides, etc. for all types of boundary conditions.\n\nTODO need to add a domain ID for extending to Schwarz\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping-Tuple{DofManager, Symbol, Symbol}","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"BCBookKeeping(\n    dof::DofManager,\n    var_name::Symbol,\n    sset_name::Symbol\n) -> FiniteElementContainers.BCBookKeeping{Vector{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping-Tuple{DofManager, Vector{Symbol}, Vector{Symbol}}","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"BCBookKeeping(\n    dof::DofManager,\n    var_names::Vector{Symbol},\n    sset_names::Vector{Symbol}\n) -> FiniteElementContainers.BCBookKeeping{Vector{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values!-Tuple{Any, Any, Any, KernelAbstractions.Backend}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values!","text":"_update_bc_values!(\n    bc,\n    X,\n    t,\n    backend::KernelAbstractions.Backend\n)\n\n\nGPU kernel wrapper for updating bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values!-Tuple{Any, Any, Any, KernelAbstractions.CPU}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values!","text":"_update_bc_values!(bc, X, t, _::KernelAbstractions.CPU)\n\n\nCPU implementation for updating stored bc values  based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values_kernel!-Tuple{Any}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values_kernel!","text":"_update_bc_values_kernel!(\n    dev\n) -> Union{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.DynamicSize, KernelAbstractions.NDIteration.DynamicSize, typeof(FiniteElementContainers.cpu__update_bc_values_kernel!)}, KernelAbstractions.Kernel{Backend, KernelAbstractions.NDIteration.DynamicSize, KernelAbstractions.NDIteration.DynamicSize, typeof(FiniteElementContainers.gpu__update_bc_values_kernel!)} where Backend<:KernelAbstractions.GPU}\n\n\nGPU kernel for updating stored bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.update_bc_values!-Tuple{Any, Any, Any}","page":"Boundary Conditions","title":"FiniteElementContainers.update_bc_values!","text":"update_bc_values!(bcs, X, t)\n\n\nWrapper that is generic for all architectures to update bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractBC}","page":"Boundary Conditions","title":"KernelAbstractions.get_backend","text":"get_backend(x::FiniteElementContainers.AbstractBC) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.BCBookKeeping}","page":"Boundary Conditions","title":"KernelAbstractions.get_backend","text":"get_backend(\n    bk::FiniteElementContainers.BCBookKeeping\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/","page":"Fields","title":"Fields","text":"CurrentModule = FiniteElementContainers","category":"page"},{"location":"fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields serve as loose wrappers around AbstractArray subtypes such that the size of array slices are known at compile time. Although this introduces a type-instability, the idea is to do this at the top most level (mainly at setup time of a FEM simulation). By introducing this type instability, we can gain information about the field type that is used in methods downstream to construct StaticArrays of views of field types.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"All fields are subtypes of the abstract type AbstractField","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using FiniteElementContainers\nAbstractField","category":"page"},{"location":"fields/#Example-H1Field-a.k.a.-NodalField","page":"Fields","title":"Example - H1Field a.k.a. NodalField","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"We can set up a H1Field in one of two ways. The simplest constructor form can be used as follows","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using FiniteElementContainers\nfield = H1Field(rand(2, 10), (:field_1, :field_2))","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"This is stored in a vectorized way as can be seen above","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field.vals","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields can be indexed like regular arrays, e.g.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field[1, 1]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field[1, :]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"etc.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"But they can also be indexed by the symbols provided during construction","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field[:field_1]","category":"page"},{"location":"fields/#Abstract-type","page":"Fields","title":"Abstract type","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"The base type for fields is the AbstractField abstract type. ","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [FiniteElementContainers]\nPages = [\"fields/Fields.jl\"]\nOrder = [:type]","category":"page"},{"location":"fields/#FiniteElementContainers.AbstractField","page":"Fields","title":"FiniteElementContainers.AbstractField","text":"abstract type AbstractField{T, N, NF, Vals, SymIDMap} <: AbstractArray{T, N}\n\nThin wrapper that subtypes AbstractArray and serves as the base Field type\n\n\n\n\n\n","category":"type"},{"location":"fields/","page":"Fields","title":"Fields","text":"Any new field added to FiniteElementContainers should be a subtype of this type.","category":"page"},{"location":"fields/#Methods-for-AbstractField","page":"Fields","title":"Methods for AbstractField","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [FiniteElementContainers]\nPages = [\"fields/Fields.jl\"]\nOrder = [:function]","category":"page"},{"location":"fields/#Base.eltype-Union{Tuple{Type{FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NF}, Tuple{N}, Tuple{T}} where {T, N, NF, Vals, SymIDMap}","page":"Fields","title":"Base.eltype","text":"eltype(\n    _::Type{FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.names-Union{Tuple{FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NF}, Tuple{N}, Tuple{T}} where {T, N, NF, Vals, SymIDMap}","page":"Fields","title":"Base.names","text":"names(\n    _::FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers._sym_id_map-Union{Tuple{SymIDMap}, Tuple{Vals}, Tuple{NF}, Tuple{N}, Tuple{T}, Tuple{FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}, Symbol}} where {T, N, NF, Vals, SymIDMap}","page":"Fields","title":"FiniteElementContainers._sym_id_map","text":"_sym_id_map(\n    _::FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap},\n    sym::Symbol\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_fields-Union{Tuple{FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NF}, Tuple{N}, Tuple{T}} where {T, N, NF, Vals, SymIDMap}","page":"Fields","title":"FiniteElementContainers.num_fields","text":"num_fields(\n    _::FiniteElementContainers.AbstractField{T, N, NF, Vals, SymIDMap}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractField}","page":"Fields","title":"KernelAbstractions.get_backend","text":"get_backend(\n    field::FiniteElementContainers.AbstractField\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#Implementations","page":"Fields","title":"Implementations","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"The existing direct subtypes of AbstractField are the following","category":"page"},{"location":"fields/#Connectivity","page":"Fields","title":"Connectivity","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"The connectivity type is a simple alias for L2ElementField defined below","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [FiniteElementContainers]\nPages = [\"fields/Connectivity.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"fields/#FiniteElementContainers.Connectivity","page":"Fields","title":"FiniteElementContainers.Connectivity","text":"struct L2ElementField{T, NN, Vals, SymIDMap} <: FiniteElementContainers.AbstractField{T, 2, NN, Vals, SymIDMap}\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.Connectivity-Union{Tuple{Any}, Tuple{Tup}} where Tup","page":"Fields","title":"FiniteElementContainers.Connectivity","text":"\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.connectivity-Tuple{Connectivity, Int64}","page":"Fields","title":"FiniteElementContainers.connectivity","text":"connectivity(\n    conn::Connectivity,\n    e::Int64\n) -> SubArray{T, 1} where T\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.connectivity-Tuple{Connectivity}","page":"Fields","title":"FiniteElementContainers.connectivity","text":"connectivity(conn::Connectivity) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#H1-field","page":"Fields","title":"H1 field","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [FiniteElementContainers]\nPages = [\"fields/H1Field.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"fields/#FiniteElementContainers.H1Field","page":"Fields","title":"FiniteElementContainers.H1Field","text":"struct H1Field{T, NF, Vals<:AbstractArray{T, 1}, SymIDMap} <: FiniteElementContainers.AbstractField{T, 2, NF, Vals<:AbstractArray{T, 1}, SymIDMap}\n\nImplementation of fields that live on nodes.\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.H1Field-Union{Tuple{M}, Tuple{NN}, Tuple{NF}, Tuple{M, Any}} where {NF, NN, M<:(AbstractMatrix{<:Number})}","page":"Fields","title":"FiniteElementContainers.H1Field","text":"H1Field{NF, NN}(vals::M) where {NF, NN, M <: AbstractArray{<:Number, 2}}\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.H1Field-Union{Tuple{Tup}, Tuple{Any, Any}} where Tup","page":"Fields","title":"FiniteElementContainers.H1Field","text":"\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.H1Field-Union{Tuple{V}, Tuple{NN}, Tuple{NF}, Tuple{V, Any}} where {NF, NN, V<:(AbstractVector{<:Number})}","page":"Fields","title":"FiniteElementContainers.H1Field","text":"H1Field{NF, NN}(vals::V) where {NF, NN, V <: AbstractArray{<:Number, 1}}\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.similar-Union{Tuple{H1Field{T, NF, Vals, SymIDMap}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NF}, Tuple{T}} where {T, NF, Vals, SymIDMap}","page":"Fields","title":"Base.similar","text":"similar(field::H1Field{T, NF, Vals, SymIDMap}) -> H1Field\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_nodes-Union{Tuple{H1Field{T, NF, Vals, SymIDMap}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NF}, Tuple{T}} where {T, NF, Vals, SymIDMap}","page":"Fields","title":"FiniteElementContainers.num_nodes","text":"num_nodes(field::H1Field{T, NF, Vals, SymIDMap}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#L2Element-field","page":"Fields","title":"L2Element field","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [FiniteElementContainers]\nPages = [\"fields/L2ElementField.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"fields/#FiniteElementContainers.L2ElementField","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"struct L2ElementField{T, NN, Vals<:AbstractArray{T, 1}, SymIDMap} <: FiniteElementContainers.AbstractField{T, 2, NN, Vals<:AbstractArray{T, 1}, SymIDMap}\n\nImplementation of fields that live on elements.\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.L2ElementField-Union{Tuple{M}, Tuple{NE}, Tuple{NN}, Tuple{M, Any}} where {NN, NE, M<:(AbstractMatrix{<:Number})}","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.L2ElementField-Union{Tuple{Tup}, Tuple{Any, Any}} where Tup","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.L2ElementField-Union{Tuple{V}, Tuple{NN}, Tuple{NF}, Tuple{V, Any}} where {NF, NN, V<:(AbstractVector{<:Number})}","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"\n\n\n\n","category":"method"},{"location":"fields/#Base.similar-Union{Tuple{Connectivity{T, NN, Vals, SymIDMap}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NN}, Tuple{T}} where {T, NN, Vals, SymIDMap}","page":"Fields","title":"Base.similar","text":"similar(\n    field::L2ElementField{T, NN, Vals, SymIDMap}\n) -> L2ElementField\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_elements-Union{Tuple{Connectivity{T, NN, Vals, SymIDMap}}, Tuple{SymIDMap}, Tuple{Vals}, Tuple{NN}, Tuple{T}} where {T, NN, Vals, SymIDMap}","page":"Fields","title":"FiniteElementContainers.num_elements","text":"num_elements(\n    field::L2ElementField{T, NN, Vals, SymIDMap}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_nodes_per_element-Tuple{L2ElementField}","page":"Fields","title":"FiniteElementContainers.num_nodes_per_element","text":"num_nodes_per_element(field::L2ElementField) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#L2Quadrature-field","page":"Fields","title":"L2Quadrature field","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [FiniteElementContainers]\nPages = [\"fields/L2QuadratureField.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"fields/#FiniteElementContainers.L2QuadratureField","page":"Fields","title":"FiniteElementContainers.L2QuadratureField","text":"struct L2QuadratureField{T, NF, NQ, Vals<:AbstractArray{T, 1}, SymIDMap} <: FiniteElementContainers.AbstractField{T, 3, NF, Vals<:AbstractArray{T, 1}, SymIDMap}\n\nImplementation of fields that live on elements.\n\n\n\n\n\n","category":"type"},{"location":"fields/","page":"Fields","title":"Fields","text":"There are plans to add HcurlField and HdivField types as well","category":"page"}]
}
