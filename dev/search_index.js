var documenterSearchIndex = {"docs":
[{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/#FiniteElementContainers.update_bc_values!-Tuple{Parameters}","page":"Parameters","title":"FiniteElementContainers.update_bc_values!","text":"update_bc_values!(p::Parameters)\n\n\nThis method is used to update the stored bc values. This should be called at the beginning of any load step\n\nTODO need to incorporate other bcs besides H1 spaces TODO need to incorporate neumann bc updates\n\n\n\n\n\n","category":"method"},{"location":"function_spaces/#FunctionSpace","page":"Function spaces","title":"FunctionSpace","text":"","category":"section"},{"location":"function_spaces/","page":"Function spaces","title":"Function spaces","text":"using Exodus, FiniteElementContainers\nmesh = UnstructuredMesh(\"../../test/poisson/poisson.g\")\nV = FunctionSpace(mesh, H1Field, Lagrange)","category":"page"},{"location":"function_spaces/#API","page":"Function spaces","title":"API","text":"","category":"section"},{"location":"function_spaces/#FiniteElementContainers.AbstractFunctionSpace","page":"Function spaces","title":"FiniteElementContainers.AbstractFunctionSpace","text":"abstract type AbstractFunctionSpace\n\n\n\n\n\n","category":"type"},{"location":"function_spaces/#FiniteElementContainers.FunctionSpace","page":"Function spaces","title":"FiniteElementContainers.FunctionSpace","text":"struct FunctionSpace{Coords, ElemConns, RefFEs} <: FiniteElementContainers.AbstractFunctionSpace\n\ncoords::Any\nelem_conns::Any\nref_fes::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"AbstractFunctions are used to represent elements of FunctionSpaces.","category":"page"},{"location":"functions/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"functions/#FiniteElementContainers.AbstractFunction","page":"Functions","title":"FiniteElementContainers.AbstractFunction","text":"abstract type AbstractFunction{S, F<:FunctionSpace}\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.ScalarFunction","page":"Functions","title":"FiniteElementContainers.ScalarFunction","text":"struct ScalarFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.ScalarFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.ScalarFunction","text":"ScalarFunction(\n    fspace::FunctionSpace,\n    sym\n) -> ScalarFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.SymmetricTensorFunction","page":"Functions","title":"FiniteElementContainers.SymmetricTensorFunction","text":"struct SymmetricTensorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.SymmetricTensorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.SymmetricTensorFunction","text":"SymmetricTensorFunction(\n    fspace::FunctionSpace,\n    sym;\n    use_spatial_dimension\n) -> SymmetricTensorFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\nUses numbering consistent with exodus output, is this the right thing to do? Should it be consistent with Tensors.jl\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.TensorFunction","page":"Functions","title":"FiniteElementContainers.TensorFunction","text":"struct TensorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.TensorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.TensorFunction","text":"TensorFunction(\n    fspace::FunctionSpace,\n    sym;\n    use_spatial_dimension\n) -> TensorFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.VectorFunction","page":"Functions","title":"FiniteElementContainers.VectorFunction","text":"struct VectorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.VectorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.VectorFunction","text":"VectorFunction(\n    fspace::FunctionSpace,\n    sym\n) -> VectorFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.length-Union{Tuple{FiniteElementContainers.AbstractFunction{S, F}}, Tuple{F}, Tuple{S}} where {S, F}","page":"Functions","title":"Base.length","text":"length(\n    _::FiniteElementContainers.AbstractFunction{S, F}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.names-Union{Tuple{FiniteElementContainers.AbstractFunction{S, F}}, Tuple{F}, Tuple{S}} where {S, F}","page":"Functions","title":"Base.names","text":"names(\n    _::FiniteElementContainers.AbstractFunction{S, F}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Assemblers","page":"Assemblers","title":"Assemblers","text":"","category":"section"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"This section describes the assemblers that are currently available and their abstract interface.","category":"page"},{"location":"assemblers/","page":"Assemblers","title":"Assemblers","text":"All assemblers must possess at minimum a DofManager.","category":"page"},{"location":"assemblers/#Matrices","page":"Assemblers","title":"Matrices","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers._assemble_block_matrix!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{Patt}, Tuple{P}, Tuple{Func}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Patt, Phys, R, F2, F2, F3, S, S, P, T, T, C, Int64, Func, KernelAbstractions.Backend}} where {C<:(L2ElementField), F1<:(AbstractVector{<:Number}), F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, Func<:Function, P<:(Union{var\"#s33\", var\"#s32\"} where {var\"#s33\"<:(StaticArraysCore.SVector), var\"#s32\"<:L2ElementField}), Patt<:FiniteElementContainers.SparsityPattern, Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_matrix!","text":"_assemble_block_matrix!(\n    field::AbstractVector{<:Number},\n    pattern::FiniteElementContainers.SparsityPattern,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s33\", var\"#s32\"} where {var\"#s33\"<:(StaticArraysCore.SVector), var\"#s32\"<:L2ElementField},\n    t::Number,\n    dt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    backend::KernelAbstractions.Backend\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_matrix!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{Patt}, Tuple{P}, Tuple{Func}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Patt, Phys, R, F2, F2, F3, S, S, P, T, T, C, Int64, Func, KernelAbstractions.CPU}} where {C<:(L2ElementField), F1<:(AbstractVector{<:Number}), F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, Func<:Function, P<:(Union{var\"#s28\", var\"#s27\"} where {var\"#s28\"<:(StaticArraysCore.SVector), var\"#s27\"<:L2ElementField}), Patt<:FiniteElementContainers.SparsityPattern, Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_matrix!","text":"_assemble_block_matrix!(\n    field::AbstractVector{<:Number},\n    pattern::FiniteElementContainers.SparsityPattern,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s28\", var\"#s27\"} where {var\"#s28\"<:(StaticArraysCore.SVector), var\"#s27\"<:L2ElementField},\n    t::Number,\n    dt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_matrix!-Union{Tuple{F}, Tuple{Any, Any, Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_matrix!","text":"assemble_matrix!(\n    storage,\n    pattern,\n    dof,\n    func::Function,\n    Uu,\n    p\n)\n\n\nNote this is hard coded to storing the assembled sparse matrix in  the stiffness_storage field of assembler.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Matrix-Action","page":"Assemblers","title":"Matrix Action","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers._assemble_block_matrix_action!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{Func}, Tuple{P}, Tuple{F4}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Phys, R, F2, F2, F3, F4, S, S, P, T, T, C, Int64, Func, KernelAbstractions.CPU}} where {C<:(L2ElementField), F1<:FiniteElementContainers.AbstractField, F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, F4<:FiniteElementContainers.AbstractField, P<:(Union{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:(StaticArraysCore.SVector), var\"#s30\"<:L2ElementField}), Func<:Function, Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_matrix_action!","text":"_assemble_block_matrix_action!(\n    field::FiniteElementContainers.AbstractField,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    V::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:(StaticArraysCore.SVector), var\"#s30\"<:L2ElementField},\n    t::Number,\n    Δt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO improve typing of fields to ensure they mathc up in terms of function    spaces\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_matrix_action!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{P}, Tuple{Func}, Tuple{F4}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Phys, R, F2, F2, F3, F4, S, S, P, T, T, C, Int64, Func, KernelAbstractions.Backend}} where {C<:(L2ElementField), F1<:FiniteElementContainers.AbstractField, F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, F4<:FiniteElementContainers.AbstractField, Func<:Function, P<:(Union{var\"#s176\", var\"#s34\"} where {var\"#s176\"<:(StaticArraysCore.SVector), var\"#s34\"<:L2ElementField}), Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_matrix_action!","text":"_assemble_block_matrix_action!(\n    field::FiniteElementContainers.AbstractField,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    V::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s176\", var\"#s34\"} where {var\"#s176\"<:(StaticArraysCore.SVector), var\"#s34\"<:L2ElementField},\n    t::Number,\n    Δt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    backend::KernelAbstractions.Backend\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Matrix-Action-2","page":"Assemblers","title":"Matrix Action","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers._assemble_block_vector_neumann_bc!-Union{Tuple{N}, Tuple{T}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{F1, F2, F3, T, N, KernelAbstractions.Backend}} where {F1<:FiniteElementContainers.AbstractField, F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, T<:Number, N<:FiniteElementContainers.NeumannBCContainer}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_vector_neumann_bc!","text":"_assemble_block_vector_neumann_bc!(\n    field::FiniteElementContainers.AbstractField,\n    U::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    t::Number,\n    bc::FiniteElementContainers.NeumannBCContainer,\n    backend::KernelAbstractions.Backend\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_vector_neumann_bc!-Union{Tuple{N}, Tuple{T}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{F1, F2, F3, T, N, KernelAbstractions.CPU}} where {F1<:FiniteElementContainers.AbstractField, F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, T<:Number, N<:FiniteElementContainers.NeumannBCContainer}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_vector_neumann_bc!","text":"_assemble_block_vector_neumann_bc!(\n    field::FiniteElementContainers.AbstractField,\n    U::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    t::Number,\n    bc::FiniteElementContainers.NeumannBCContainer,\n    _::KernelAbstractions.CPU\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_vector_neumann_bc!-Tuple{Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers.assemble_vector_neumann_bc!","text":"assemble_vector_neumann_bc!(assembler, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Scalar","page":"Assemblers","title":"Scalar","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers._assemble_block_quadrature_quantity!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{Func}, Tuple{P}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Phys, R, F2, F2, F3, S, S, P, T, T, C, Int64, Func, KernelAbstractions.CPU}} where {C<:(L2ElementField), F1<:(AbstractMatrix{<:Number}), F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, P<:(Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:(StaticArraysCore.SVector), var\"#s28\"<:L2ElementField}), Func<:Function, Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_quadrature_quantity!","text":"_assemble_block_quadrature_quantity!(\n    field::AbstractMatrix{<:Number},\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:(StaticArraysCore.SVector), var\"#s28\"<:L2ElementField},\n    t::Number,\n    Δt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO improve typing of fields to ensure they mathc up in terms of function    spaces\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_quadrature_quantity!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{P}, Tuple{Func}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Phys, R, F2, F2, F3, S, S, P, T, T, C, Int64, Func, KernelAbstractions.Backend}} where {C<:(L2ElementField), F1<:(AbstractMatrix{<:Number}), F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, Func<:Function, P<:(Union{var\"#s33\", var\"#s32\"} where {var\"#s33\"<:(StaticArraysCore.SVector), var\"#s32\"<:L2ElementField}), Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_quadrature_quantity!","text":"_assemble_block_quadrature_quantity!(\n    field::AbstractMatrix{<:Number},\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s33\", var\"#s32\"} where {var\"#s33\"<:(StaticArraysCore.SVector), var\"#s32\"<:L2ElementField},\n    t::Number,\n    Δt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    backend::KernelAbstractions.Backend\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_quadrature_quantity!-Union{Tuple{F}, Tuple{Any, Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_quadrature_quantity!","text":"assemble_quadrature_quantity!(\n    storage,\n    dof,\n    func::Function,\n    Uu,\n    p\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_scalar!-Union{Tuple{F}, Tuple{Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_scalar!","text":"assemble_scalar!(assembler, func::Function, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Vector","page":"Assemblers","title":"Vector","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers._assemble_block_vector!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{Func}, Tuple{P}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Phys, R, F2, F2, F3, S, S, P, T, T, C, Int64, Func, KernelAbstractions.CPU}} where {C<:(L2ElementField), F1<:FiniteElementContainers.AbstractField, F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, P<:(Union{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:(StaticArraysCore.SVector), var\"#s30\"<:L2ElementField}), Func<:Function, Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_vector!","text":"_assemble_block_vector!(\n    field::FiniteElementContainers.AbstractField,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:(StaticArraysCore.SVector), var\"#s30\"<:L2ElementField},\n    t::Number,\n    Δt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    _::KernelAbstractions.CPU\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO improve typing of fields to ensure they mathc up in terms of function    spaces\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_vector!-Union{Tuple{T}, Tuple{S}, Tuple{R}, Tuple{Phys}, Tuple{P}, Tuple{Func}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{C}, Tuple{F1, Phys, R, F2, F2, F3, S, S, P, T, T, C, Int64, Func, KernelAbstractions.Backend}} where {C<:(L2ElementField), F1<:FiniteElementContainers.AbstractField, F2<:FiniteElementContainers.AbstractField, F3<:FiniteElementContainers.AbstractField, Func<:Function, P<:(Union{var\"#s176\", var\"#s34\"} where {var\"#s176\"<:(StaticArraysCore.SVector), var\"#s34\"<:L2ElementField}), Phys<:AbstractPhysics, R<:ReferenceFiniteElements.ReferenceFE, S<:L2QuadratureField, T<:Number}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_vector!","text":"_assemble_block_vector!(\n    field::FiniteElementContainers.AbstractField,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    state_old::L2QuadratureField,\n    state_new::L2QuadratureField,\n    props::Union{var\"#s176\", var\"#s34\"} where {var\"#s176\"<:(StaticArraysCore.SVector), var\"#s34\"<:L2ElementField},\n    t::Number,\n    Δt::Number,\n    conns::L2ElementField,\n    block_id::Int64,\n    func::Function,\n    backend::KernelAbstractions.Backend\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_vector!-Union{Tuple{F}, Tuple{Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_vector!","text":"assemble_vector!(assembler, func::Function, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Abstract-Interface","page":"Assemblers","title":"Abstract Interface","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers.AbstractAssembler","page":"Assemblers","title":"FiniteElementContainers.AbstractAssembler","text":"abstract type AbstractAssembler{Dof<:DofManager}\n\n\n\n\n\n","category":"type"},{"location":"assemblers/#FiniteElementContainers._assemble_element!-Tuple{H1Field, Vararg{Any, 4}}","page":"Assemblers","title":"FiniteElementContainers._assemble_element!","text":"_assemble_element!(\n    global_val::H1Field,\n    local_val,\n    conn,\n    e,\n    b\n)\n\n\nAssembly method for an H1Field, e.g. internal force Called on a single element e for a given block b where local_val has already been constructed from quadrature contributions.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._cell_interpolants-Union{Tuple{R}, Tuple{R, Int64}} where R<:ReferenceFiniteElements.ReferenceFE","page":"Assemblers","title":"FiniteElementContainers._cell_interpolants","text":"_cell_interpolants(\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    q::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_fields-Tuple{H1Field, Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_level_fields","text":"_element_level_fields(U::H1Field, ref_fe, conns, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_fields_flat-Tuple{H1Field, Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_level_fields_flat","text":"_element_level_fields_flat(\n    U::H1Field,\n    ref_fe,\n    conns,\n    e\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_properties-Tuple{L2ElementField, Int64}","page":"Assemblers","title":"FiniteElementContainers._element_level_properties","text":"_element_level_properties(\n    props::L2ElementField,\n    e::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_properties-Union{Tuple{T}, Tuple{NP}, Tuple{StaticArraysCore.SVector{NP, T}, Int64}} where {NP, T}","page":"Assemblers","title":"FiniteElementContainers._element_level_properties","text":"_element_level_properties(\n    props::StaticArraysCore.SArray{Tuple{NP}, T, 1, NP},\n    _::Int64\n) -> StaticArraysCore.SVector\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch_matrix-Tuple{Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch_matrix","text":"_element_scratch_matrix(ref_fe, U) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch_vector-Tuple{Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch_vector","text":"_element_scratch_vector(ref_fe, U) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._quadrature_level_state-Tuple{L2QuadratureField, Int64, Int64}","page":"Assemblers","title":"FiniteElementContainers._quadrature_level_state","text":"_quadrature_level_state(\n    state::L2QuadratureField,\n    q::Int64,\n    e::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.hvp-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.hvp","text":"hvp(asm::FiniteElementContainers.AbstractAssembler) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.mass-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.mass","text":"mass(\n    assembler::FiniteElementContainers.AbstractAssembler\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.residual-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.residual","text":"residual(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\nassumes assemble_vector! has already been called\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.stiffness-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.stiffness","text":"stiffness(\n    assembler::FiniteElementContainers.AbstractAssembler\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"KernelAbstractions.get_backend","text":"get_backend(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#SparseMatrixAssembler","page":"Assemblers","title":"SparseMatrixAssembler","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers.SparseMatrixAssembler","page":"Assemblers","title":"FiniteElementContainers.SparseMatrixAssembler","text":"struct SparseMatrixAssembler{Dof<:DofManager, Pattern<:FiniteElementContainers.SparsityPattern, Storage1<:(AbstractVector{<:Number}), Storage2<:FiniteElementContainers.AbstractField, Storage3<:NamedTuple} <: FiniteElementContainers.AbstractAssembler{Dof<:DofManager}\n\nGeneral sparse matrix assembler that can handle first or second order problems in time. \n\n\n\n\n\n","category":"type"},{"location":"assemblers/#FiniteElementContainers.SparseMatrixAssembler-Tuple{DofManager}","page":"Assemblers","title":"FiniteElementContainers.SparseMatrixAssembler","text":"SparseMatrixAssembler(\n    dof::DofManager\n) -> SparseMatrixAssembler{Dof, Pattern, Vector{Float64}, Storage2, Storage3} where {Dof<:DofManager, Pattern<:(FiniteElementContainers.SparsityPattern{Vector{Int64}, _A, Vector{Float64}} where _A), Storage2<:FiniteElementContainers.AbstractField, Storage3<:(NamedTuple{_A, Tuple{Vararg{Matrix{Float64}, N}}} where {_A, N})}\n\n\nConstruct a SparseMatrixAssembler for a specific field type,  e.g. H1Field. Can be used to create block arrays for mixed FEM problems.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_element!-Tuple{FiniteElementContainers.SparsityPattern, Any, StaticArraysCore.SMatrix, Int64, Int64}","page":"Assemblers","title":"FiniteElementContainers._assemble_element!","text":"_assemble_element!(\n    pattern::FiniteElementContainers.SparsityPattern,\n    storage,\n    K_el::StaticArraysCore.SMatrix,\n    el_id::Int64,\n    block_id::Int64\n)\n\n\nSpecialization of of _assemble_element! for SparseMatrixAssembler.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#SparsityPattern","page":"Assemblers","title":"SparsityPattern","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers.SparsityPattern","page":"Assemblers","title":"FiniteElementContainers.SparsityPattern","text":"struct SparsityPattern{I<:AbstractVector{Int64}, B, R<:AbstractVector{Float64}}\n\nIs::AbstractVector{Int64}\nJs::AbstractVector{Int64}\nunknown_dofs::AbstractVector{Int64}\nblock_sizes::Any\nblock_offsets::Any\nklasttouch::AbstractVector{Int64}\ncsrrowptr::AbstractVector{Int64}\ncsrcolval::AbstractVector{Int64}\ncsrnzval::AbstractVector{Float64}\ncsccolptr::AbstractVector{Int64}\ncscrowval::AbstractVector{Int64}\ncscnzval::AbstractVector{Float64}\n\nBook-keeping struct for sparse matrices in FEM settings. This has all the information to construct a sparse matrix for either case where you want to eliminate fixed-dofs or not.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This section describes the user facing API for boundary conditions along with the implementation details.","category":"page"},{"location":"boundary_conditions/#DirichletBC","page":"Boundary Conditions","title":"DirichletBC","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We can set up dirichlet boundary conditions on a variable u and sideset sset_1 with a zero function as follows.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using FiniteElementContainers\nbc_func(x, t) = 0.\nbc = DirichletBC(:u, :sset_1, bc_func)","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Internally this is eventually converted in a DirichletBCContainer","category":"page"},{"location":"boundary_conditions/#API","page":"Boundary Conditions","title":"API","text":"","category":"section"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractDirichletBC{F}\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\nUser facing API to define a DirichletBC`.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC-Tuple{String, String, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractDirichletBC{F}\n\nDirichletBC(\n    var_name::String,\n    sset_name::String,\n    func::Function\n) -> DirichletBC{F} where F<:Function\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC-Tuple{Symbol, Symbol, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractDirichletBC{F}\n\nDirichletBC(\n    var_name::Symbol,\n    sset_name::Symbol,\n    func::Function\n) -> DirichletBC{F} where F<:Function\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBCContainer","text":"struct DirichletBCContainer{IT<:Integer, VT<:Number, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:Number, 1}} <: FiniteElementContainers.AbstractDirichletBCContainer{IT<:Integer, VT<:Number, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:Number, 1}}\n\nbookkeeping::FiniteElementContainers.BCBookKeeping{IT, IV, IM} where {IT<:Integer, IV<:AbstractVector{IT}, IM<:AbstractMatrix{IT}}\nvals::AbstractVector{VT} where VT<:Number\nvals_dot::AbstractVector{VT} where VT<:Number\nvals_dot_dot::AbstractVector{VT} where VT<:Number\n\nInternal implementation of dirichlet BCs\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBCContainer-Tuple{Any, DofManager, DirichletBC}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBCContainer","text":"struct DirichletBCContainer{IT<:Integer, VT<:Number, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:Number, 1}} <: FiniteElementContainers.AbstractDirichletBCContainer{IT<:Integer, VT<:Number, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:Number, 1}}\n\nDirichletBCContainer(\n    mesh,\n    dof::DofManager,\n    dbc::DirichletBC\n) -> FiniteElementContainers.DirichletBCContainer{Int64, Float64, Vector{Int64}, M, Vector{Float64}} where M<:AbstractMatrix{Int64}\n\n\nbookkeeping::FiniteElementContainers.BCBookKeeping{IT, IV, IM} where {IT<:Integer, IV<:AbstractVector{IT}, IM<:AbstractMatrix{IT}}\nvals::AbstractVector{VT} where VT<:Number\nvals_dot::AbstractVector{VT} where VT<:Number\nvals_dot_dot::AbstractVector{VT} where VT<:Number\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values!-Tuple{FiniteElementContainers.DirichletBCContainer, Any, Any, Any, KernelAbstractions.Backend}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values!","text":"_update_bc_values!(\n    bc::FiniteElementContainers.DirichletBCContainer,\n    func,\n    X,\n    t,\n    backend::KernelAbstractions.Backend\n)\n\n\nGPU kernel wrapper for updating bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values!-Tuple{FiniteElementContainers.DirichletBCContainer, Any, Any, Any, KernelAbstractions.CPU}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values!","text":"_update_bc_values!(\n    bc::FiniteElementContainers.DirichletBCContainer,\n    func,\n    X,\n    t,\n    _::KernelAbstractions.CPU\n)\n\n\nCPU implementation for updating stored bc values  based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBC","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBC","text":"struct NeumannBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\nUser facing API to define a NeumannBC`.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBC-Tuple{String, Symbol, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBC","text":"struct NeumannBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nNeumannBC(\n    var_name::String,\n    sset_name::Symbol,\n    func::Function\n)\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBC-Tuple{Symbol, Symbol, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBC","text":"struct NeumannBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nNeumannBC(\n    var_name::Symbol,\n    sset_name::Symbol,\n    func::Function\n) -> NeumannBC{<:Function}\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBCContainer","text":"struct NeumannBCContainer{IT<:Integer, VT<:(Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:Number, var\"#s28\"<:(StaticArraysCore.SVector)}), IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:(Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:Number, var\"#s28\"<:(StaticArraysCore.SVector)}), 2}, C1, C2, RE<:ReferenceFiniteElements.ReferenceFE} <: FiniteElementContainers.AbstractBCContainer{IT<:Integer, VT<:(Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:Number, var\"#s28\"<:(StaticArraysCore.SVector)}), 2, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:(Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:Number, var\"#s28\"<:(StaticArraysCore.SVector)}), 2}}\n\nbookkeeping::FiniteElementContainers.BCBookKeeping{IT, IV, IM} where {IT<:Integer, IV<:AbstractVector{IT}, IM<:AbstractMatrix{IT}}\nelement_conns::Any\nsurface_conns::Any\nref_fe::ReferenceFiniteElements.ReferenceFE\nvals::AbstractMatrix{VT} where VT<:(Union{var\"#s29\", var\"#s28\"} where {var\"#s29\"<:Number, var\"#s28\"<:(StaticArraysCore.SVector)})\n\nInternal implementation of dirichlet BCs\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#Boundary-Condition-Implementation-Details","page":"Boundary Conditions","title":"Boundary Condition Implementation Details","text":"","category":"section"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBC","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBC","text":"abstract type AbstractBC{F<:Function}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBCContainer","text":"abstract type AbstractBCContainer{IT<:Integer, VT<:(Union{var\"#s34\", var\"#s33\"} where {var\"#s34\"<:Number, var\"#s33\"<:(StaticArraysCore.SVector)}), N, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, VV<:AbstractArray{VT<:(Union{var\"#s34\", var\"#s33\"} where {var\"#s34\"<:Number, var\"#s33\"<:(StaticArraysCore.SVector)}), N}}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBCFunction","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBCFunction","text":"abstract type AbstractBCFunction{F}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"struct BCBookKeeping{I<:Integer, V<:AbstractArray{I<:Integer, 1}, M<:AbstractArray{I<:Integer, 2}}\n\nblocks::AbstractVector{I} where I<:Integer\ndofs::AbstractVector{I} where I<:Integer\nelements::AbstractVector{I} where I<:Integer\nnodes::AbstractVector{I} where I<:Integer\nsides::AbstractVector{I} where I<:Integer\nside_nodes::AbstractMatrix{I} where I<:Integer\n\nThis struct is used to help with book keeping nodes, sides, etc. for all types of boundary conditions.\n\nTODO need to add a domain ID for extending to Schwarz\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping-Tuple{Any, DofManager, Symbol, Symbol}","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"BCBookKeeping(\n    mesh,\n    dof::DofManager,\n    var_name::Symbol,\n    sset_name::Symbol\n) -> FiniteElementContainers.BCBookKeeping{Int64, Vector{Int64}, M} where M<:AbstractMatrix{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.update_bc_values!-NTuple{4, Any}","page":"Boundary Conditions","title":"FiniteElementContainers.update_bc_values!","text":"update_bc_values!(bcs, funcs, X, t)\n\n\nWrapper that is generic for all architectures to update bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.BCBookKeeping}","page":"Boundary Conditions","title":"KernelAbstractions.get_backend","text":"get_backend(\n    bk::FiniteElementContainers.BCBookKeeping\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes/","page":"Meshes","title":"Meshes","text":"Meshes in FiniteElementContainers leverage a very abstract interface. No single mesh format is directly supported in the main src code but rather different mesh types are relegated to package extensions. Currently, only an Exodus package extension is supported but others could be readily supported.","category":"page"},{"location":"meshes/#FiniteElementContainers.AbstractMesh","page":"Meshes","title":"FiniteElementContainers.AbstractMesh","text":"abstract type AbstractMesh\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.FileMesh","page":"Meshes","title":"FiniteElementContainers.FileMesh","text":"struct FileMesh{MeshObj} <: FiniteElementContainers.AbstractMesh\n\nfile_name::String\nmesh_obj::Any\n\nMesh type that has a handle to an open mesh file object. This type's methods are \"overridden\" in extensions.\n\nSee FiniteElementContainersExodusExt for an example.\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"struct UnstructuredMesh{MeshObj, X, EBlockNames, ETypes, EConns, EMaps, NSetNodes, SSetIVs, SSetIMs, EdgeConns, FaceConns} <: FiniteElementContainers.AbstractMesh\n\nmesh_obj::Any\nnodal_coords::Any\nelement_block_names::Any\nelement_types::Any\nelement_conns::Any\nelement_id_maps::Any\nnodeset_nodes::Any\nsideset_elems::Any\nsideset_nodes::Any\nsideset_sides::Any\nsideset_side_nodes::Any\nedge_conns::Any\nface_conns::Any\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Tuple{Any, String, Bool, Bool}","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file_type,\n    file_name::String,\n    create_edges::Bool,\n    create_faces::Bool\n)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Tuple{String}","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file_name::String;\n    create_edges,\n    create_faces\n)\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.coordinates-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.coordinates","text":"coordinates(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.copy_mesh","page":"Meshes","title":"FiniteElementContainers.copy_mesh","text":"Dummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"function"},{"location":"meshes/#FiniteElementContainers.element_block_id_map-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.element_block_id_map","text":"element_block_id_map(\n    _::FiniteElementContainers.AbstractMesh,\n    id\n)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_ids-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.element_block_ids","text":"element_block_ids(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_names-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.element_block_names","text":"element_block_names(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_connectivity-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.element_connectivity","text":"element_connectivity(\n    _::FiniteElementContainers.AbstractMesh,\n    id\n)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_type-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.element_type","text":"element_type(_::FiniteElementContainers.AbstractMesh, id)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.file_name-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.file_name","text":"file_name(mesh::FiniteElementContainers.AbstractMesh) -> Any\n\n\nReturns file name for an mesh type\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.nodeset","text":"nodeset(_::FiniteElementContainers.AbstractMesh, id)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset_ids-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.nodeset_ids","text":"nodeset_ids(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset_names-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.nodeset_names","text":"nodeset_names(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodesets-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.nodesets","text":"nodesets(_::FiniteElementContainers.AbstractMesh, ids)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.num_dimensions-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.num_dimensions","text":"num_dimensions(\n    _::FiniteElementContainers.AbstractMesh\n) -> Any\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.num_nodes-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.num_nodes","text":"num_nodes(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset-Tuple{FiniteElementContainers.AbstractMesh, Any}","page":"Meshes","title":"FiniteElementContainers.sideset","text":"sideset(_::FiniteElementContainers.AbstractMesh, id)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset_ids-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.sideset_ids","text":"sideset_ids(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset_names-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.sideset_names","text":"sideset_names(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sidesets-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.sidesets","text":"sidesets(_::FiniteElementContainers.AbstractMesh)\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\n","category":"method"},{"location":"fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields serve as loose wrappers around AbstractArray subtypes such that the size of array slices are known at compile time. Although this introduces a type-instability, the idea is to do this at the top most level (mainly at setup time of a FEM simulation). By introducing this type instability, we can gain information about the field type that is used in methods downstream to construct StaticArrays of views of field types.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"All fields are subtypes of the abstract type AbstractField","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using FiniteElementContainers\nAbstractField","category":"page"},{"location":"fields/#Example-H1Field-a.k.a.-NodalField","page":"Fields","title":"Example - H1Field a.k.a. NodalField","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"We can set up a H1Field in one of two ways. The simplest constructor form can be used as follows","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using FiniteElementContainers\nfield = H1Field(rand(2, 10), (:field_1, :field_2))","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"This is stored in a vectorized way as can be seen above","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field.vals","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields can be indexed like regular arrays, e.g.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field[1, 1]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field[1, :]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"etc.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"But they can also be indexed by the symbols provided during construction","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"field[:field_1]","category":"page"},{"location":"fields/#Abstract-type","page":"Fields","title":"Abstract type","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"The base type for fields is the AbstractField abstract type. ","category":"page"},{"location":"fields/#FiniteElementContainers.AbstractField","page":"Fields","title":"FiniteElementContainers.AbstractField","text":"abstract type AbstractField{T, N, D<:AbstractArray{T, 1}, NF} <: AbstractArray{T, N}\n\nThin wrapper that subtypes AbstractArray and serves as the base Field type\n\n\n\n\n\n","category":"type"},{"location":"fields/","page":"Fields","title":"Fields","text":"Any new field added to FiniteElementContainers should be a subtype of this type.","category":"page"},{"location":"fields/#Methods-for-AbstractField","page":"Fields","title":"Methods for AbstractField","text":"","category":"section"},{"location":"fields/#Base.fill!-Union{Tuple{NF}, Tuple{D}, Tuple{N}, Tuple{T}, Tuple{FiniteElementContainers.AbstractField{T, N, D, NF}, T}} where {T, N, D, NF}","page":"Fields","title":"Base.fill!","text":"fill!(\n    field::FiniteElementContainers.AbstractField{T, N, D, NF},\n    v\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_fields-Union{Tuple{FiniteElementContainers.AbstractField{T, N, D, NF}}, Tuple{NF}, Tuple{D}, Tuple{N}, Tuple{T}} where {T, N, D, NF}","page":"Fields","title":"FiniteElementContainers.num_fields","text":"num_fields(\n    _::FiniteElementContainers.AbstractField{T, N, D, NF}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractField}","page":"Fields","title":"KernelAbstractions.get_backend","text":"get_backend(\n    field::FiniteElementContainers.AbstractField\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#Implementations","page":"Fields","title":"Implementations","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"The existing direct subtypes of AbstractField are the following","category":"page"},{"location":"fields/#Connectivity","page":"Fields","title":"Connectivity","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"The connectivity type is a simple alias for L2ElementField defined below","category":"page"},{"location":"fields/#FiniteElementContainers.Connectivity","page":"Fields","title":"FiniteElementContainers.Connectivity","text":"struct L2ElementField{T, D, NF} <: FiniteElementContainers.AbstractField{T, 2, D, NF}\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.connectivity-Tuple{L2ElementField, Int64}","page":"Fields","title":"FiniteElementContainers.connectivity","text":"connectivity(\n    conn::L2ElementField,\n    e::Int64\n) -> SubArray{T, 1} where T\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.connectivity-Tuple{L2ElementField}","page":"Fields","title":"FiniteElementContainers.connectivity","text":"connectivity(conn::L2ElementField) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#H1-field","page":"Fields","title":"H1 field","text":"","category":"section"},{"location":"fields/#FiniteElementContainers.H1Field","page":"Fields","title":"FiniteElementContainers.H1Field","text":"struct H1Field{T, D, NF} <: FiniteElementContainers.AbstractField{T, 2, D, NF}\n\nImplementation of fields that live on nodes.\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.H1Field-Tuple{M} where M<:(AbstractMatrix)","page":"Fields","title":"FiniteElementContainers.H1Field","text":"H1Field(data::AbstractMatrix) -> H1Field\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_nodes-Union{Tuple{H1Field{T, D, NF}}, Tuple{NF}, Tuple{D}, Tuple{T}} where {T, D, NF}","page":"Fields","title":"FiniteElementContainers.num_nodes","text":"num_nodes(field::H1Field{T, D, NF}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#L2Element-field","page":"Fields","title":"L2Element field","text":"","category":"section"},{"location":"fields/#FiniteElementContainers.L2ElementField","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"struct L2ElementField{T, D, NF} <: FiniteElementContainers.AbstractField{T, 2, D, NF}\n\nImplementation of fields that live on elements.\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.L2ElementField-Tuple{M} where M<:(AbstractMatrix)","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"L2ElementField(data::AbstractMatrix) -> L2ElementField\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_elements-Union{Tuple{L2ElementField{T, D, NF}}, Tuple{NF}, Tuple{D}, Tuple{T}} where {T, D, NF}","page":"Fields","title":"FiniteElementContainers.num_elements","text":"num_elements(field::L2ElementField{T, D, NF}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_nodes_per_element-Tuple{L2ElementField}","page":"Fields","title":"FiniteElementContainers.num_nodes_per_element","text":"num_nodes_per_element(field::L2ElementField) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#L2Quadrature-field","page":"Fields","title":"L2Quadrature field","text":"","category":"section"},{"location":"fields/#FiniteElementContainers.L2QuadratureField","page":"Fields","title":"FiniteElementContainers.L2QuadratureField","text":"struct L2QuadratureField{T, D, NF, NQ} <: FiniteElementContainers.AbstractField{T, 3, D, NF}\n\nImplementation of fields that live on elements.\n\n\n\n\n\n","category":"type"},{"location":"fields/","page":"Fields","title":"Fields","text":"There are plans to add HcurlField and HdivField types as well","category":"page"},{"location":"formulations/#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"formulations/#FiniteElementContainers.AbstractMechanicsFormulation","page":"Formulations","title":"FiniteElementContainers.AbstractMechanicsFormulation","text":"abstract type AbstractMechanicsFormulation{ND}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#Implementations","page":"Formulations","title":"Implementations","text":"","category":"section"},{"location":"formulations/#FiniteElementContainers.IncompressiblePlaneStress","page":"Formulations","title":"FiniteElementContainers.IncompressiblePlaneStress","text":"struct IncompressiblePlaneStress <: AbstractMechanicsFormulation{2}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.PlaneStrain","page":"Formulations","title":"FiniteElementContainers.PlaneStrain","text":"struct PlaneStrain <: AbstractMechanicsFormulation{2}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.ScalarFormulation","page":"Formulations","title":"FiniteElementContainers.ScalarFormulation","text":"struct ScalarFormulation <: AbstractMechanicsFormulation{1}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.ThreeDimensional","page":"Formulations","title":"FiniteElementContainers.ThreeDimensional","text":"struct ThreeDimensional <: AbstractMechanicsFormulation{3}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#Methods","page":"Formulations","title":"Methods","text":"","category":"section"},{"location":"formulations/#FiniteElementContainers.discrete_gradient","page":"Formulations","title":"FiniteElementContainers.discrete_gradient","text":"discrete_gradient(_::IncompressiblePlaneStress, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::PlaneStrain, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::ScalarFormulation, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::ThreeDimensional, ∇N_X) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.discrete_symmetric_gradient","page":"Formulations","title":"FiniteElementContainers.discrete_symmetric_gradient","text":"discrete_symmetric_gradient(\n    _::IncompressiblePlaneStress,\n    ∇N_X\n) -> Any\n\n\n\n\n\n\ndiscrete_symmetric_gradient(_::PlaneStrain, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_symmetric_gradient(_::ScalarFormulation, ∇N_X)\n\n\n\n\n\n\ndiscrete_symmetric_gradient(\n    _::ThreeDimensional,\n    ∇N_X\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.discrete_values","page":"Formulations","title":"FiniteElementContainers.discrete_values","text":"discrete_values(_::IncompressiblePlaneStress, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::PlaneStrain, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::ScalarFormulation, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::ThreeDimensional, N) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.extract_stiffness","page":"Formulations","title":"FiniteElementContainers.extract_stiffness","text":"extract_stiffness(\n    _::IncompressiblePlaneStress,\n    A::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stiffness(\n    _::PlaneStrain,\n    A::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stiffness(\n    _::ThreeDimensional,\n    A_in::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.extract_stress","page":"Formulations","title":"FiniteElementContainers.extract_stress","text":"extract_stress(\n    _::IncompressiblePlaneStress,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stress(\n    _::PlaneStrain,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stress(\n    _::ThreeDimensional,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.modify_field_gradients","page":"Formulations","title":"FiniteElementContainers.modify_field_gradients","text":"modify_field_gradients(\n    _::IncompressiblePlaneStress,\n    ∇u_q::StaticArraysCore.SArray{Tuple{2, 2}, T<:Number, 2, 4}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\nmodify_field_gradients(\n    _::PlaneStrain,\n    ∇u_q::StaticArraysCore.SArray{Tuple{2, 2}, T<:Number, 2, 4}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\nmodify_field_gradients(\n    _::ThreeDimensional,\n    ∇u_q::StaticArraysCore.SArray{Tuple{3, 3}, T<:Number, 2, 9}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.num_dimensions","page":"Formulations","title":"FiniteElementContainers.num_dimensions","text":"num_dimensions(\n    _::FiniteElementContainers.AbstractMesh\n) -> Any\n\n\nDummy method to be overriden for specific mesh file format\n\n\n\n\n\nnum_dimensions(_::AbstractMechanicsFormulation{ND}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"physics/#FiniteElementContainers.create_properties-Union{Tuple{AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"FiniteElementContainers.create_properties","text":"create_properties(\n    physics::AbstractPhysics{NF, NP, NS}\n) -> StaticArraysCore.SVector{0, Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#FiniteElementContainers.reshape_element_level_coordinates-Union{Tuple{T}, Tuple{NxD}, Tuple{I}, Tuple{I, StaticArraysCore.SVector{NxD, T}}} where {I<:ReferenceFiniteElements.AbstractInterpolants, NxD, T<:Number}","page":"Physics","title":"FiniteElementContainers.reshape_element_level_coordinates","text":"reshape_element_level_coordinates(\n    interps::ReferenceFiniteElements.AbstractInterpolants,\n    x_el::StaticArraysCore.SArray{Tuple{NxD}, T<:Number, 1, NxD}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#FiniteElementContainers.reshape_element_level_field-Union{Tuple{T}, Tuple{NxNDof}, Tuple{P}, Tuple{P, StaticArraysCore.SVector{NxNDof, T}}} where {P<:AbstractPhysics, NxNDof, T<:Number}","page":"Physics","title":"FiniteElementContainers.reshape_element_level_field","text":"reshape_element_level_field(\n    physics::AbstractPhysics,\n    u_el::StaticArraysCore.SArray{Tuple{NxNDof}, T<:Number, 1, NxNDof}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#DofManager","page":"DofManager","title":"DofManager","text":"","category":"section"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"The DofManager is a struct that keeps track of which dofs are unknown or constrained. This can work with simple or mixed finite element spaces of various types. It is a glorified book keeper.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"A DofManager can be created as follows. First we must create functions for our variables of interest from their associated function spaces.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"using Exodus, FiniteElementContainers\nmesh = UnstructuredMesh(\"../../test/poisson/poisson.g\")\nV = FunctionSpace(mesh, H1Field, Lagrange)\nu = VectorFunction(V, :u)\nt = ScalarFunction(V, :t)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"Now we can supply these variables to the DofManager which takes varargs as inputs","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"dof = DofManager(u, t)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"The print methods for this struct show simple metadata about the current dofs for each possible function space.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"A set of unknowns can be set up as follows","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"field = create_unknowns(dof)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"We can create fields of the right size from the DofManager with the following methods","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"field = create_field(dof, H1Field)","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"These methods take the backed of dof into account to ensure that the fields or unknowns produced are on the same device, e.g. CPU/GPU if dof is on the CPU/GPU.","category":"page"},{"location":"dof_manager/","page":"DofManager","title":"DofManager","text":"This struct is created with all dofs initially set as unknown. To modify the unknowns we can do the following","category":"page"},{"location":"dof_manager/#API","page":"DofManager","title":"API","text":"","category":"section"},{"location":"#FiniteElementContainers","page":"Home","title":"FiniteElementContainers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FiniteElementContainers.jl is a package whose main purpose is to help  researchers develop new finite element method (FEM) applications for both well known existing techniques and new novel strategies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is specificially designed with the challenging aspects of computational solid mechanics in mind where meshes deform, there's path dependence, there's contact between bodies, there are potentially heterogeneous material properties, and other challenges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're primarily interested in writing FEM applications for e.g. the Poisson equation or heat equation, there's likely more efficient packages (e.g. Gridap or Ferrite) out there for this purpose in terms of memory and computational efficiency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, if you need to solve problems with multiple material models, meshes where there are mixed elements types, etc. this is likely the only julia package at the time of writing this that supports such capabilities. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inspiration for the software design primarily comes from fenics and MOOSE. We've specifically designed the interface to get around all the shortcomings of fenics  (e.g. boundary conditions are a pain, mixed element types a plain, different blocks are pain etc.) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our goal is also to ensure all of our methods are next generation hardware capable. This means not only supporting things on CPUs but also GPUs (and that doesn't just mean NVIDIA).","category":"page"}]
}
