var documenterSearchIndex = {"docs":
[{"location":"tutorials/3_coupled_problem/#3.-Coupled-Example","page":"3 Coupled Problem","title":"3. Coupled Example","text":"This example mimics the second Moose tutorial.","category":"section"},{"location":"tutorials/3_coupled_problem/#Strong-Form","page":"3 Coupled Problem","title":"Strong Form","text":"Consider the advection equation on a domain Omega subset mathbbR^d with boundary partial Omega:\n\nbeginaligned -nabla cdot nabla u + nabla v cdotnabla u = 0 quad textin  Omeganewline -nablacdotnabla v = 0quad textin  Omega endaligned\n\nwith Dirichlet boundary conditions\n\nbeginaligned u(x) = g_1quadtextfor xinpartialOmega_d_1 newline v(x) = g_2quadtextfor xinpartialOmega_d_2 endaligned\n\nand Neumann boundary conditions\n\nbeginaligned -mathbfncdotnabla u = h_1 newline -mathbfncdotnabla v = h_2 endaligned","category":"section"},{"location":"tutorials/3_coupled_problem/#Weak-form","page":"3 Coupled Problem","title":"Weak form","text":"beginaligned int_Omega (nabla w_1cdotnabla u + w_1nabla vcdotnabla u)dOmega = int_partialOmega_1 w_1h_1dGamma newline int_Omega nabla w_2cdotnabla vdOmega = int_partialOmega_2 w_2h_2dGamma newline endaligned","category":"section"},{"location":"tutorials/3_coupled_problem/#Implementation","page":"3 Coupled Problem","title":"Implementation","text":"struct CoupledPhysics <: AbstractPhysics{2, 0, 0}\nend\n\n@inline function FiniteElementContainers.residual(\n    physics::CoupledPhysics, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n    interps = map_interpolants(interps, x_el)\n    (; X_q, N, ∇N_X, JxW) = interps\n    ∇u_q = interpolate_field_gradients(physics, interps, u_el)\n    ∇u = unpack_field(∇u_q, 1)\n    ∇v = unpack_field(∇u_q, 2)\n    term = dot(∇u, ∇v)\n    R_u = ∇N_X * ∇u + term * N\n    R_v = ∇N_X * ∇v\n    R = vcat(R_u', R_v')\n    return JxW * R[:]\nend\n\n# begin lazy below\n@inline function FiniteElementContainers.stiffness(\n    physics::CoupledPhysics, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n    ForwardDiff.jacobian(\n        z -> FiniteElementContainers.residual(\n            physics, interps, x_el, t, dt, z, u_el_old, state_old_q, state_new_q, props_el\n        ), u_el\n    )\nend","category":"section"},{"location":"tutorials/3_coupled_problem/#Example-problem","page":"3 Coupled Problem","title":"Example problem","text":"one_func(_, _) = 1.0\ntwo_func(_, _) = 2.0\nzero_func(_, _) = 0.0\n\nmesh = UnstructuredMesh(\"mug.e\")\nV = FunctionSpace(mesh, H1Field, Lagrange)\nphysics = CoupledPhysics()\nprops = create_properties(physics)\nu = FiniteElementContainers.GeneralFunction(\n    ScalarFunction(V, :u),\n    ScalarFunction(V, :v)\n)\n\nasm = SparseMatrixAssembler(u; use_condensed=true)\ndbcs = [\n    DirichletBC(:u, two_func; sideset_name = :bottom)\n    DirichletBC(:u, zero_func; sideset_name = :top)\n    DirichletBC(:v, one_func; sideset_name = :bottom)\n    DirichletBC(:v, zero_func; sideset_name = :top)\n]\nU = create_field(asm)\np = create_parameters(mesh, asm, physics, props; dirichlet_bcs = dbcs)\n\nsolver = NewtonSolver(DirectLinearSolver(asm))\nintegrator = QuasiStaticIntegrator(solver)\nevolve!(integrator, p)\n\nU = p.h1_field\n\npp = PostProcessor(mesh, \"output.e\", u)\nwrite_times(pp, 1, 0.0)\nwrite_field(pp, 1, (\"u\", \"v\"), U)\nclose(pp)\n\nVisualized results (Image: ) (Image: )","category":"section"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/#FiniteElementContainers.AbstractParameters","page":"Parameters","title":"FiniteElementContainers.AbstractParameters","text":"abstract type AbstractParameters\n\n\n\n\n\n","category":"type"},{"location":"parameters/#FiniteElementContainers.Parameters","page":"Parameters","title":"FiniteElementContainers.Parameters","text":"struct Parameters{RT<:Number, RV<:AbstractArray{RT<:Number, 1}, IV<:(AbstractVector{<:Integer}), ICFuncs<:NamedTuple, DBCFuncs<:NamedTuple, NBCs<:NeumannBCs, Phys<:NamedTuple, Props<:NamedTuple, S<:NamedTuple, NDims, NH1Fields} <: FiniteElementContainers.AbstractParameters\n\nics::InitialConditions{IV, RV} where {RT<:Number, RV<:AbstractVector{RT}, IV<:(AbstractVector{<:Integer})}\ndirichlet_bcs::DirichletBCs{IV, RV} where {RT<:Number, RV<:AbstractVector{RT}, IV<:(AbstractVector{<:Integer})}\nneumann_bcs::NeumannBCs\ntimes::TimeStepper{RV} where {RT<:Number, RV<:AbstractVector{RT}}\nphysics::NamedTuple\nproperties::NamedTuple\nstate_old::NamedTuple\nstate_new::NamedTuple\nh1_coords::H1Field{RT, RV} where {RT<:Number, RV<:AbstractVector{RT}}\nh1_field::H1Field{RT, RV} where {RT<:Number, RV<:AbstractVector{RT}}\nh1_field_old::H1Field{RT, RV} where {RT<:Number, RV<:AbstractVector{RT}}\nh1_hvp_scratch_field::H1Field{RT, RV} where {RT<:Number, RV<:AbstractVector{RT}}\n\n\n\n\n\n","category":"type"},{"location":"parameters/#FiniteElementContainers.Parameters-NTuple{8, Any}","page":"Parameters","title":"FiniteElementContainers.Parameters","text":"Parameters(\n    mesh,\n    assembler,\n    physics,\n    properties,\n    ics,\n    dirichlet_bcs,\n    neumann_bcs,\n    times\n) -> Parameters{RT, _A, IV, ICFuncs, DBCFuncs, NBCs, Phys, Props, S} where {RT<:Number, _A<:AbstractVector{RT}, IV<:(AbstractVector{<:Integer}), ICFuncs<:NamedTuple, DBCFuncs<:NamedTuple, NBCs<:(NeumannBCs{BCCaches, BCFuncs} where {BCCaches<:(NamedTuple{_A, <:Tuple{Vararg{FiniteElementContainers.NeumannBCContainer}}} where _A), BCFuncs<:(NamedTuple{_A, <:Tuple{Vararg{Function}}} where _A)}), Phys<:NamedTuple, Props<:NamedTuple, S<:(NamedTuple{_A, Tuple{Vararg{Array{Float64, 3}, N}}} where {_A, N})}\n\n\n\n\n\n\n","category":"method"},{"location":"parameters/#FiniteElementContainers.initialize!-Tuple{Parameters}","page":"Parameters","title":"FiniteElementContainers.initialize!","text":"initialize!(p::Parameters)\n\n\n\n\n\n\n","category":"method"},{"location":"parameters/#FiniteElementContainers.update_bc_values!-Tuple{Parameters}","page":"Parameters","title":"FiniteElementContainers.update_bc_values!","text":"update_bc_values!(p::Parameters)\n\n\nThis method is used to update the stored bc values. This should be called at the beginning of any load step\n\nTODO need to incorporate other bcs besides H1 spaces TODO need to incorporate neumann bc updates\n\n\n\n\n\n","category":"method"},{"location":"parameters/#FiniteElementContainers.update_dofs!-Tuple{FiniteElementContainers.AbstractAssembler, Parameters}","page":"Parameters","title":"FiniteElementContainers.update_dofs!","text":"update_dofs!(\n    asm::FiniteElementContainers.AbstractAssembler,\n    p::Parameters\n)\n\n\n\n\n\n\n","category":"method"},{"location":"parameters/#FiniteElementContainers.update_time!-Tuple{Parameters}","page":"Parameters","title":"FiniteElementContainers.update_time!","text":"update_time!(p::Parameters)\n\n\n\n\n\n\n","category":"method"},{"location":"function_spaces/#FunctionSpace","page":"Function spaces","title":"FunctionSpace","text":"using Exodus, FiniteElementContainers\nmesh = UnstructuredMesh(\"../../test/poisson/poisson.g\")\nV = FunctionSpace(mesh, H1Field, Lagrange)","category":"section"},{"location":"function_spaces/#API","page":"Function spaces","title":"API","text":"","category":"section"},{"location":"function_spaces/#FiniteElementContainers.AbstractFunctionSpace","page":"Function spaces","title":"FiniteElementContainers.AbstractFunctionSpace","text":"abstract type AbstractFunctionSpace\n\n\n\n\n\n","category":"type"},{"location":"function_spaces/#FiniteElementContainers.FunctionSpace","page":"Function spaces","title":"FiniteElementContainers.FunctionSpace","text":"struct FunctionSpace{Coords, ElemConns, RefFEs} <: FiniteElementContainers.AbstractFunctionSpace\n\ncoords::Any\nelem_conns::Any\nref_fes::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"AbstractFunctions are used to represent elements of FunctionSpaces.","category":"section"},{"location":"functions/#API","page":"Functions","title":"API","text":"","category":"section"},{"location":"functions/#FiniteElementContainers.AbstractFunction","page":"Functions","title":"FiniteElementContainers.AbstractFunction","text":"abstract type AbstractFunction{S, F<:FunctionSpace}\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.ScalarFunction","page":"Functions","title":"FiniteElementContainers.ScalarFunction","text":"struct ScalarFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.ScalarFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.ScalarFunction","text":"ScalarFunction(\n    fspace::FunctionSpace,\n    sym\n) -> ScalarFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.SymmetricTensorFunction","page":"Functions","title":"FiniteElementContainers.SymmetricTensorFunction","text":"struct SymmetricTensorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.SymmetricTensorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.SymmetricTensorFunction","text":"SymmetricTensorFunction(\n    fspace::FunctionSpace,\n    sym;\n    use_spatial_dimension\n) -> SymmetricTensorFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\nUses numbering consistent with exodus output, is this the right thing to do? Should it be consistent with Tensors.jl\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.TensorFunction","page":"Functions","title":"FiniteElementContainers.TensorFunction","text":"struct TensorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.TensorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.TensorFunction","text":"TensorFunction(\n    fspace::FunctionSpace,\n    sym;\n    use_spatial_dimension\n) -> TensorFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#FiniteElementContainers.VectorFunction","page":"Functions","title":"FiniteElementContainers.VectorFunction","text":"struct VectorFunction{S, F} <: FiniteElementContainers.AbstractFunction{S, F}\n\nfspace::Any\n\n\n\n\n\n","category":"type"},{"location":"functions/#FiniteElementContainers.VectorFunction-Tuple{FunctionSpace, Any}","page":"Functions","title":"FiniteElementContainers.VectorFunction","text":"VectorFunction(\n    fspace::FunctionSpace,\n    sym\n) -> VectorFunction{_A, FunctionSpace{Coords, ElemConns, RefFEs}} where {_A, Coords, ElemConns, RefFEs}\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.length-Union{Tuple{FiniteElementContainers.AbstractFunction{S, F}}, Tuple{F}, Tuple{S}} where {S, F}","page":"Functions","title":"Base.length","text":"length(\n    _::FiniteElementContainers.AbstractFunction{S, F}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.names-Union{Tuple{FiniteElementContainers.AbstractFunction{S, F}}, Tuple{F}, Tuple{S}} where {S, F}","page":"Functions","title":"Base.names","text":"names(\n    _::FiniteElementContainers.AbstractFunction{S, F}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#Assemblers","page":"Assemblers","title":"Assemblers","text":"This section describes the assemblers that are currently available and their abstract interface.\n\nAll assemblers must possess at minimum a DofManager.\n\nThe assemblers possess all the baggage to use the internal method sparse! in SparseArrays.jl. This method allows for a zero allocation instantiation of a SparseMatrixCSC type on the CPU. There are also methods available to ease in the conversion of CSC types and other sparse types such as CSR. \n\nOn the GPU, however, this type is first converted to an appropriate COO matrix type on the desired backend. There is unfortunately not a unified sparse matrix API in julia for GPUs, so we implement this functionality in package extensions. On CUDA, for example, the operational sequence to get a CuSparseMatrixCSC is to first sort the COO (row, col, val) triplets so they are ordered by row and then column. Then a CuSparseMatrixCOO type is created and converted to a CuSparseMatrixCSC type via CUDA.jl methods. An identical approach is taken for RocM types.\n\nNOTE: This is one of the most actively developed areas of the package. Please use caution with any method beginning with a \"_\" as these are internal methods that will change without notice.","category":"section"},{"location":"assemblers/#Matrices","page":"Assemblers","title":"Matrices","text":"","category":"section"},{"location":"assemblers/#Matrix-Action","page":"Assemblers","title":"Matrix Action","text":"","category":"section"},{"location":"assemblers/#Matrix-Action-2","page":"Assemblers","title":"Matrix Action","text":"","category":"section"},{"location":"assemblers/#Scalar","page":"Assemblers","title":"Scalar","text":"","category":"section"},{"location":"assemblers/#Vector","page":"Assemblers","title":"Vector","text":"","category":"section"},{"location":"assemblers/#Abstract-Interface","page":"Assemblers","title":"Abstract Interface","text":"","category":"section"},{"location":"assemblers/#SparseMatrixAssembler","page":"Assemblers","title":"SparseMatrixAssembler","text":"","category":"section"},{"location":"assemblers/#SparsityPattern","page":"Assemblers","title":"SparsityPattern","text":"","category":"section"},{"location":"assemblers/#FiniteElementContainers.assemble_matrix!-Union{Tuple{F}, Tuple{Any, Any, Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_matrix!","text":"assemble_matrix!(\n    storage,\n    pattern,\n    dof,\n    func::Function,\n    Uu,\n    p\n)\n\n\nNote this is hard coded to storing the assembled sparse matrix in  the stiffness_storage field of assembler.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_matrix_action!-Union{Tuple{S}, Tuple{Solution}, Tuple{T}, Tuple{KernelAbstractions.Backend, FiniteElementContainers.AbstractField, L2ElementField, Any, Any, Function, AbstractPhysics, ReferenceFiniteElements.ReferenceFE, FiniteElementContainers.AbstractField, T, T, Solution, Solution, Solution, S, S, AbstractArray, Any}} where {T<:Number, Solution<:FiniteElementContainers.AbstractField, S}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_matrix_action!","text":"_assemble_block_matrix_action!(\n    backend::KernelAbstractions.Backend,\n    field::FiniteElementContainers.AbstractField,\n    conns::L2ElementField,\n    b1,\n    b2,\n    func::Function,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    X::FiniteElementContainers.AbstractField,\n    t::Number,\n    Δt::Number,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    V::FiniteElementContainers.AbstractField,\n    state_old,\n    state_new,\n    props::AbstractArray,\n    return_type\n)\n\n\nAssembly method for a block labelled as block_id. This is a GPU agnostic implementation using KernelAbstractions and Atomix for eliminating race conditions\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_matrix_action!-Union{Tuple{S}, Tuple{Solution}, Tuple{T}, Tuple{KernelAbstractions.CPU, FiniteElementContainers.AbstractField, L2ElementField, Any, Any, Function, AbstractPhysics, ReferenceFiniteElements.ReferenceFE, FiniteElementContainers.AbstractField, T, T, Solution, Solution, Solution, S, S, AbstractArray, Any}} where {T<:Number, Solution<:FiniteElementContainers.AbstractField, S}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_matrix_action!","text":"_assemble_block_matrix_action!(\n    _::KernelAbstractions.CPU,\n    field::FiniteElementContainers.AbstractField,\n    conns::L2ElementField,\n    b1,\n    b2,\n    func::Function,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    X::FiniteElementContainers.AbstractField,\n    t::Number,\n    Δt::Number,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    V::FiniteElementContainers.AbstractField,\n    state_old,\n    state_new,\n    props::AbstractArray,\n    return_type\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO improve typing of fields to ensure they mathc up in terms of function    spaces\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_matrix_action!-NTuple{6, Any}","page":"Assemblers","title":"FiniteElementContainers.assemble_matrix_action!","text":"assemble_matrix_action!(storage, dof, func, Uu, Vu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_matrix_action!-Union{Tuple{F}, Tuple{Any, F, Any, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_matrix_action!","text":"assemble_matrix_action!(\n    assembler,\n    func::Function,\n    Uu,\n    Vu,\n    p\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_vector_neumann_bc!-Tuple{KernelAbstractions.Backend, FiniteElementContainers.AbstractField, FiniteElementContainers.AbstractField, FiniteElementContainers.AbstractField, FiniteElementContainers.NeumannBCContainer}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_vector_neumann_bc!","text":"_assemble_block_vector_neumann_bc!(\n    backend::KernelAbstractions.Backend,\n    field::FiniteElementContainers.AbstractField,\n    U::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    bc::FiniteElementContainers.NeumannBCContainer\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_block_vector_neumann_bc!-Tuple{KernelAbstractions.CPU, FiniteElementContainers.AbstractField, FiniteElementContainers.AbstractField, FiniteElementContainers.AbstractField, FiniteElementContainers.NeumannBCContainer}","page":"Assemblers","title":"FiniteElementContainers._assemble_block_vector_neumann_bc!","text":"_assemble_block_vector_neumann_bc!(\n    _::KernelAbstractions.CPU,\n    field::FiniteElementContainers.AbstractField,\n    U::FiniteElementContainers.AbstractField,\n    X::FiniteElementContainers.AbstractField,\n    bc::FiniteElementContainers.NeumannBCContainer\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_vector_neumann_bc!-NTuple{4, Any}","page":"Assemblers","title":"FiniteElementContainers.assemble_vector_neumann_bc!","text":"assemble_vector_neumann_bc!(storage, dof, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_vector_neumann_bc!-Tuple{Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers.assemble_vector_neumann_bc!","text":"assemble_vector_neumann_bc!(assembler, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_quadrature_quantity!-Union{Tuple{F}, Tuple{Any, Any, Any, F, Any, Any}, Tuple{Any, Any, Any, F, Any, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_quadrature_quantity!","text":"assemble_quadrature_quantity!(\n    storage,\n    pattern,\n    dof,\n    func::Function,\n    Uu,\n    p\n)\nassemble_quadrature_quantity!(\n    storage,\n    pattern,\n    dof,\n    func::Function,\n    Uu,\n    p,\n    return_type\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_scalar!-Union{Tuple{F}, Tuple{Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_scalar!","text":"assemble_scalar!(assembler, func::Function, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_vector!-Union{Tuple{F}, Tuple{Any, Any, Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_vector!","text":"assemble_vector!(\n    storage,\n    pattern,\n    dof,\n    func::Function,\n    Uu,\n    p\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.assemble_vector!-Union{Tuple{F}, Tuple{Any, F, Any, Any}} where F<:Function","page":"Assemblers","title":"FiniteElementContainers.assemble_vector!","text":"assemble_vector!(assembler, func::Function, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.AbstractAssembler","page":"Assemblers","title":"FiniteElementContainers.AbstractAssembler","text":"abstract type AbstractAssembler{Dof<:DofManager}\n\n\n\n\n\n","category":"type"},{"location":"assemblers/#FiniteElementContainers._assemble_block!-Union{Tuple{R}, Tuple{S}, Tuple{Solution}, Tuple{T}, Tuple{KernelAbstractions.CPU, Any, L2ElementField, Int64, Int64, Function, AbstractPhysics, ReferenceFiniteElements.ReferenceFE, FiniteElementContainers.AbstractField, T, T, Solution, Solution, S, S, AbstractArray, R}} where {T<:Number, Solution<:FiniteElementContainers.AbstractField, S, R<:FiniteElementContainers.AssembledReturnType}","page":"Assemblers","title":"FiniteElementContainers._assemble_block!","text":"_assemble_block!(\n    _::KernelAbstractions.CPU,\n    field,\n    conns::L2ElementField,\n    block_start_index::Int64,\n    block_el_level_size::Int64,\n    func::Function,\n    physics::AbstractPhysics,\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    X::FiniteElementContainers.AbstractField,\n    t::Number,\n    dt::Number,\n    U::FiniteElementContainers.AbstractField,\n    U_old::FiniteElementContainers.AbstractField,\n    state_old,\n    state_new,\n    props::AbstractArray,\n    return_type::FiniteElementContainers.AssembledReturnType\n)\n\n\nAssembly method for a block labelled as block_id. This is a CPU implementation with no threading.\n\nTODO add state variables and physics properties\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._assemble_element!-Tuple{Any, StaticArraysCore.SMatrix, Any, Int64, Int64, Int64}","page":"Assemblers","title":"FiniteElementContainers._assemble_element!","text":"_assemble_element!(\n    storage,\n    K_el::StaticArraysCore.SMatrix,\n    conns,\n    el_id::Int64,\n    block_start_index::Int64,\n    block_el_level_size::Int64\n)\n\n\nSpecialization of of _assemble_element! for SparseMatrixAssembler.\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._cell_interpolants-Union{Tuple{R}, Tuple{R, Int64}} where R<:ReferenceFiniteElements.ReferenceFE","page":"Assemblers","title":"FiniteElementContainers._cell_interpolants","text":"_cell_interpolants(\n    ref_fe::ReferenceFiniteElements.ReferenceFE,\n    q::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_fields-Tuple{H1Field, Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_level_fields","text":"_element_level_fields(U::H1Field, ref_fe, conns, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_fields_flat-Tuple{H1Field, Any, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_level_fields_flat","text":"_element_level_fields_flat(\n    U::H1Field,\n    ref_fe,\n    conns,\n    e\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_properties-Tuple{AbstractArray, Int64}","page":"Assemblers","title":"FiniteElementContainers._element_level_properties","text":"_element_level_properties(\n    props::AbstractArray,\n    _::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_properties-Tuple{L2ElementField, Int64}","page":"Assemblers","title":"FiniteElementContainers._element_level_properties","text":"_element_level_properties(\n    props::L2ElementField,\n    e::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_level_properties-Union{Tuple{T}, Tuple{NP}, Tuple{StaticArraysCore.SVector{NP, T}, Int64}} where {NP, T}","page":"Assemblers","title":"FiniteElementContainers._element_level_properties","text":"_element_level_properties(\n    props::StaticArraysCore.SArray{Tuple{NP}, T, 1, NP},\n    _::Int64\n) -> StaticArraysCore.SVector\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch-Tuple{FiniteElementContainers.AssembledMatrix, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch","text":"_element_scratch(\n    _::FiniteElementContainers.AssembledMatrix,\n    ref_fe,\n    U\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch-Tuple{FiniteElementContainers.AssembledScalar, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch","text":"_element_scratch(\n    _::FiniteElementContainers.AssembledScalar,\n    ref_fe,\n    U\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch-Tuple{FiniteElementContainers.AssembledStruct, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch","text":"_element_scratch(\n    _::FiniteElementContainers.AssembledStruct,\n    ref_fe,\n    U\n)\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch-Tuple{FiniteElementContainers.AssembledVector, Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch","text":"_element_scratch(\n    _::FiniteElementContainers.AssembledVector,\n    ref_fe,\n    U\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch_matrix-Tuple{Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch_matrix","text":"_element_scratch_matrix(ref_fe, U) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._element_scratch_vector-Tuple{Any, Any}","page":"Assemblers","title":"FiniteElementContainers._element_scratch_vector","text":"_element_scratch_vector(ref_fe, U) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers._quadrature_level_state-Tuple{AbstractArray{<:Number, 3}, Int64, Int64}","page":"Assemblers","title":"FiniteElementContainers._quadrature_level_state","text":"_quadrature_level_state(\n    state::AbstractArray{<:Number, 3},\n    q::Int64,\n    e::Int64\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.hessian-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.hessian","text":"hessian(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.hvp-Tuple{FiniteElementContainers.AbstractAssembler, Any}","page":"Assemblers","title":"FiniteElementContainers.hvp","text":"hvp(\n    asm::FiniteElementContainers.AbstractAssembler,\n    v\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.mass-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.mass","text":"mass(\n    assembler::FiniteElementContainers.AbstractAssembler\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.residual-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.residual","text":"residual(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\nassumes assemble_vector! has already been called\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.stiffness-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"FiniteElementContainers.stiffness","text":"stiffness(\n    assembler::FiniteElementContainers.AbstractAssembler\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractAssembler}","page":"Assemblers","title":"KernelAbstractions.get_backend","text":"get_backend(\n    asm::FiniteElementContainers.AbstractAssembler\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"assemblers/#FiniteElementContainers.SparseMatrixAssembler","page":"Assemblers","title":"FiniteElementContainers.SparseMatrixAssembler","text":"struct SparseMatrixAssembler{Condensed, NumArrDims, NumFields, IV<:AbstractVector{Int64}, RV<:AbstractVector{Float64}, Var<:FiniteElementContainers.AbstractFunction, FieldStorage<:FiniteElementContainers.AbstractField{Float64, NumArrDims, RV<:AbstractVector{Float64}, NumFields}, QuadratureStorage<:NamedTuple} <: FiniteElementContainers.AbstractAssembler{DofManager{Condensed, Int64, IV<:AbstractVector{Int64}, Var<:FiniteElementContainers.AbstractFunction}}\n\nGeneral sparse matrix assembler that can handle first or second order problems in time. \n\n\n\n\n\n","category":"type"},{"location":"assemblers/#FiniteElementContainers.SparseMatrixAssembler-Tuple{DofManager}","page":"Assemblers","title":"FiniteElementContainers.SparseMatrixAssembler","text":"SparseMatrixAssembler(\n    dof::DofManager\n) -> SparseMatrixAssembler{_A, _B, _C, Vector{Int64}, Vector{Float64}, Var, _D, QuadratureStorage} where {_A, _B, _C, Var<:FiniteElementContainers.AbstractFunction, _D<:FiniteElementContainers.AbstractField{Float64, _B, Vector{Float64}, _C}, QuadratureStorage<:(NamedTuple{_A, Tuple{Vararg{Matrix{Float64}, N}}} where {_A, N})}\n\n\nConstruct a SparseMatrixAssembler for a specific field type,  e.g. H1Field. Can be used to create block arrays for mixed FEM problems.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/4_transient_problem/#4.-Transient-Problem","page":"4 Transient Problem","title":"4. Transient Problem","text":"This example mimics the second Moose tutorial.","category":"section"},{"location":"tutorials/4_transient_problem/#Strong-Form","page":"4 Transient Problem","title":"Strong Form","text":"Consider the Poisson equation on a domain Omega subset mathbbR^d with boundary partial Omega:\n\nfracpartial upartial t -nabla cdot nabla u = 0quad textin  Omega\n\nwith initial conditions u(x) = u_0(x)\n\nwith Dirichlet boundary conditions\n\nu = g quad texton  partial Omega_D\n\nand Neumann boundary conditions\n\nnabla u cdot n = h quad texton  partial Omega_N","category":"section"},{"location":"tutorials/4_transient_problem/#Weak-form","page":"4 Transient Problem","title":"Weak form","text":"int_Omega nabla v cdot nabla u  dOmega + int_Omega v fracpartial upartial tdOmega = int_partial Omega_N v  h  dGamma where for simplicity we will approximate the time derivate by the following first order approximation\n\nfracpartial upartial t = fracu_n + 1 - u_nDelta t","category":"section"},{"location":"tutorials/4_transient_problem/#Implementation","page":"4 Transient Problem","title":"Implementation","text":"struct Transient <: AbstractPhysics{1, 0, 0}\nend\n\n@inline function FiniteElementContainers.residual(\n    physics::Transient, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n    interps = map_interpolants(interps, x_el)\n    (; X_q, N, ∇N_X, JxW) = interps\n    u_q, ∇u_q = interpolate_field_values_and_gradients(physics, interps, u_el)\n    u_q_old = interpolate_field_values(physics, interps, u_el_old)\n    ∇u = unpack_field(∇u_q, 1)\n    dudt = 20. * (u_q[1] - u_q_old[1]) / dt\n    R = dudt * N + ∇N_X * ∇u\n    return JxW * R[:]\nend\n  \n@inline function FiniteElementContainers.stiffness(\n    physics::Transient, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n    interps = map_interpolants(interps, x_el)\n    (; X_q, N, ∇N_X, JxW) = interps\n    K_q = (20. / dt) * N * N' + ∇N_X * ∇N_X'\n    return JxW * K_q\nend","category":"section"},{"location":"tutorials/4_transient_problem/#Example-problem","page":"4 Transient Problem","title":"Example problem","text":"mesh = UnstructuredMesh(\"cyl-tet.e\")\ntimes = TimeStepper(0., 75., 75)\nV = FunctionSpace(mesh, H1Field, Lagrange)\nphysics = Transient()\nprops = create_properties(physics)\nu = ScalarFunction(V, :u)\nasm = SparseMatrixAssembler(u; use_condensed=true)\ndbcs = [\n    DirichletBC(:u, zero_func; sideset_name = :bottom)\n    DirichletBC(:u, one_func; sideset_name = :top)\n]\nU = create_field(asm)\np = create_parameters(\n    mesh, asm, physics, props; \n    dirichlet_bcs = dbcs,\n    times = times\n)\nsolver = NewtonSolver(DirectLinearSolver(asm))\nintegrator = QuasiStaticIntegrator(solver)\npp = PostProcessor(mesh, \"output.e\", u)\n\nn = 1\nwhile times.time_current[1] < 75.0\n    evolve!(integrator, p)\n    U = p.h1_field\n    write_times(pp, n, times.time_current[1])\n    write_field(pp, n, (\"u\",), U)\n    n = n + 1\nend\n\nclose(pp)\n\nVisualization (Image: )","category":"section"},{"location":"tutorials/5_solid_mechanics/#5.-Solid-Mechanics","page":"5 Solid Mechanics","title":"5. Solid Mechanics","text":"For a detailed implementation of solid mechanics using FiniteElementContainers.jl please consult the Cthonios.jl documentation\n\nTODO add a simple linear elasticity example","category":"section"},{"location":"boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"This section describes the user facing API for boundary conditions along with the implementation details.","category":"section"},{"location":"boundary_conditions/#DirichletBC","page":"Boundary Conditions","title":"DirichletBC","text":"We can set up dirichlet boundary conditions on a variable u and sideset sset_1 with a zero function as follows.\n\nusing FiniteElementContainers\nbc_func(x, t) = 0.\nbc = DirichletBC(:u, bc_func; sideset_name = :sset_1)\n\nInternally this is eventually converted in a DirichletBCContainer\n\nDirichlet bcs can be setup on element blocks, nodesets, or sidesets. The appropriate keyword argument needs to be supplied with the DirichletBC constructor.","category":"section"},{"location":"boundary_conditions/#NeumannBC","page":"Boundary Conditions","title":"NeumannBC","text":"We can setup Neumann bcs on a variable u and sideset sset_1 with a simple constant function as follows\n\nusing FiniteElementContainers\nusing StaticArrays\nbc_func(x, t) = SVector{1, Float64}(1.)\nbc = NeumannBC(:u, :sset_1, bc_func)\n\nNote that in comparison to the dirichlet bc example above, the function in this case returns a SVector of size 1. This will hold for any variable u that has a single dof. For vector variables, e.g. a traction vector in continuum mechanics, would need something like\n\nusing FiniteElementContainers\nusing StaticArrays\nND = 2\nbc_func(x, t) = SVector{ND, Float64}(1.)\nbc = NeumannBC(:u, :sset_1, bc_func)\n\nwhere ND is the number of dimensions.","category":"section"},{"location":"boundary_conditions/#PeriodicBC","page":"Boundary Conditions","title":"PeriodicBC","text":"Periodic boundary conditions are very much a work in progress. There is currently some machinary to implement a Lagrange multiplier approach. \n\nStay tuned.","category":"section"},{"location":"boundary_conditions/#Boundary-Condition-Implementation-Details","page":"Boundary Conditions","title":"Boundary Condition Implementation Details","text":"","category":"section"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractDirichletBC{F}\n\nfunc::Any\nblock_name::Union{Nothing, Symbol}\nnset_name::Union{Nothing, Symbol}\nsset_name::Union{Nothing, Symbol}\nvar_name::Symbol\n\nUser facing API to define a DirichletBC`.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC-Tuple{String, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractDirichletBC{F}\n\nDirichletBC(\n    var_name::String,\n    func::Function;\n    block_name,\n    nodeset_name,\n    sideset_name\n) -> DirichletBC{F} where F<:Function\n\n\nfunc::Any\nblock_name::Union{Nothing, Symbol}\nnset_name::Union{Nothing, Symbol}\nsset_name::Union{Nothing, Symbol}\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBC-Tuple{Symbol, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBC","text":"struct DirichletBC{F} <: FiniteElementContainers.AbstractDirichletBC{F}\n\nDirichletBC(\n    var_name::Symbol,\n    func::Function;\n    block_name,\n    nodeset_name,\n    sideset_name\n) -> DirichletBC{F} where F<:Function\n\n\nfunc::Any\nblock_name::Union{Nothing, Symbol}\nnset_name::Union{Nothing, Symbol}\nsset_name::Union{Nothing, Symbol}\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBCContainer","text":"struct DirichletBCContainer{IV<:(AbstractVector{<:Integer}), RV<:(AbstractVector{<:Number})} <: FiniteElementContainers.AbstractBCContainer\n\ndofs::AbstractVector{<:Integer}\nnodes::AbstractVector{<:Integer}\nvals::AbstractVector{<:Number}\nvals_dot::AbstractVector{<:Number}\nvals_dot_dot::AbstractVector{<:Number}\n\nInternal implementation of dirichlet BCs\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.DirichletBCContainer-Tuple{Any, DofManager, DirichletBC}","page":"Boundary Conditions","title":"FiniteElementContainers.DirichletBCContainer","text":"struct DirichletBCContainer{IV<:(AbstractVector{<:Integer}), RV<:(AbstractVector{<:Number})} <: FiniteElementContainers.AbstractBCContainer\n\nDirichletBCContainer(\n    mesh,\n    dof::DofManager,\n    dbc::DirichletBC\n) -> FiniteElementContainers.DirichletBCContainer{Vector{Int64}, Vector{Float64}}\n\n\ndofs::AbstractVector{<:Integer}\nnodes::AbstractVector{<:Integer}\nvals::AbstractVector{<:Number}\nvals_dot::AbstractVector{<:Number}\nvals_dot_dot::AbstractVector{<:Number}\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values!-Tuple{FiniteElementContainers.DirichletBCContainer, Any, Any, Any, KernelAbstractions.Backend}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values!","text":"_update_bc_values!(\n    bc::FiniteElementContainers.DirichletBCContainer,\n    func,\n    X,\n    t,\n    backend::KernelAbstractions.Backend\n)\n\n\nGPU kernel wrapper for updating bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers._update_bc_values!-Tuple{FiniteElementContainers.DirichletBCContainer, Any, Any, Any, KernelAbstractions.CPU}","page":"Boundary Conditions","title":"FiniteElementContainers._update_bc_values!","text":"_update_bc_values!(\n    bc::FiniteElementContainers.DirichletBCContainer,\n    func,\n    X,\n    t,\n    _::KernelAbstractions.CPU\n)\n\n\nCPU implementation for updating stored bc values  based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBC","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBC","text":"struct NeumannBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\nUser facing API to define a NeumannBC`.\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBC-Tuple{String, String, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBC","text":"struct NeumannBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nNeumannBC(\n    var_name::String,\n    sset_name::String,\n    func::Function\n) -> NeumannBC{<:Function}\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBC-Tuple{Symbol, Symbol, Function}","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBC","text":"struct NeumannBC{F} <: FiniteElementContainers.AbstractBC{F}\n\nNeumannBC(\n    var_name::Symbol,\n    sset_name::Symbol,\n    func::Function\n) -> NeumannBC{<:Function}\n\n\nfunc::Any\nsset_name::Symbol\nvar_name::Symbol\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.NeumannBCContainer","page":"Boundary Conditions","title":"FiniteElementContainers.NeumannBCContainer","text":"struct NeumannBCContainer{IT<:Integer, IV<:AbstractArray{IT<:Integer, 1}, IM<:AbstractArray{IT<:Integer, 2}, RV<:(AbstractMatrix{<:Union{var\"#s55\", var\"#s50\"} where {var\"#s55\"<:Number, var\"#s50\"<:(StaticArraysCore.SVector)}}), C1, C2, RE<:ReferenceFiniteElements.ReferenceFE} <: FiniteElementContainers.AbstractBCContainer\n\nelement_conns::Any\nelements::AbstractVector{IT} where IT<:Integer\nside_nodes::AbstractMatrix{IT} where IT<:Integer\nsides::AbstractVector{IT} where IT<:Integer\nsurface_conns::Any\nref_fe::ReferenceFiniteElements.ReferenceFE\nvals::AbstractMatrix{<:Union{var\"#s55\", var\"#s50\"} where {var\"#s55\"<:Number, var\"#s50\"<:(StaticArraysCore.SVector)}}\n\nInternal implementation of dirichlet BCs\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBC","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBC","text":"abstract type AbstractBC{F<:Function}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.AbstractBCFunction","page":"Boundary Conditions","title":"FiniteElementContainers.AbstractBCFunction","text":"abstract type AbstractBCFunction{F}\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"struct BCBookKeeping{I<:Integer, V<:AbstractArray{I<:Integer, 1}, M<:AbstractArray{I<:Integer, 2}}\n\nblocks::AbstractVector{I} where I<:Integer\ndofs::AbstractVector{I} where I<:Integer\nelements::AbstractVector{I} where I<:Integer\nnodes::AbstractVector{I} where I<:Integer\nsides::AbstractVector{I} where I<:Integer\nside_nodes::AbstractMatrix{I} where I<:Integer\n\nThis struct is used to help with book keeping nodes, sides, etc. for all types of boundary conditions.\n\nTODO need to add a domain ID for extending to Schwarz\n\n\n\n\n\n","category":"type"},{"location":"boundary_conditions/#FiniteElementContainers.BCBookKeeping-Tuple{Any, DofManager, Symbol}","page":"Boundary Conditions","title":"FiniteElementContainers.BCBookKeeping","text":"BCBookKeeping(\n    mesh,\n    dof::DofManager,\n    var_name::Symbol;\n    block_name,\n    nset_name,\n    sset_name\n)\n\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#FiniteElementContainers.update_bc_values!-NTuple{4, Any}","page":"Boundary Conditions","title":"FiniteElementContainers.update_bc_values!","text":"update_bc_values!(bcs, funcs, X, t)\n\n\nWrapper that is generic for all architectures to update bc values based on the stored function\n\n\n\n\n\n","category":"method"},{"location":"meshes/#Meshes","page":"Meshes","title":"Meshes","text":"Meshes in FiniteElementContainers leverage a very abstract interface. Currently, only an Exodus interface is directly supported within the main package but others could be readily supported through package extensions which we are planning on.","category":"section"},{"location":"meshes/#Structured-Meshes","page":"Meshes","title":"Structured Meshes","text":"Simple structured meshes on rectangles or parallepipeds can be create through StructuredMesh mesh type.","category":"section"},{"location":"meshes/#Unstructured-Meshes","page":"Meshes","title":"Unstructured Meshes","text":"Unstructured meshes (e.g. those read from a file created by a mesher) can be created with the following mesh type","category":"section"},{"location":"meshes/#Exodus-interface-API","page":"Meshes","title":"Exodus interface API","text":"","category":"section"},{"location":"meshes/#FiniteElementContainers.AbstractMesh","page":"Meshes","title":"FiniteElementContainers.AbstractMesh","text":"abstract type AbstractMesh\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.FileMesh","page":"Meshes","title":"FiniteElementContainers.FileMesh","text":"struct FileMesh{MeshObj} <: FiniteElementContainers.AbstractMesh\n\nfile_name::String\nmesh_obj::Any\n\nMesh type that has a handle to an open mesh file object. This type's methods are \"overridden\" in extensions.\n\nSee FiniteElementContainersExodusExt for an example.\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.file_name-Tuple{FiniteElementContainers.AbstractMesh}","page":"Meshes","title":"FiniteElementContainers.file_name","text":"file_name(mesh::FiniteElementContainers.AbstractMesh) -> Any\n\n\nReturns file name for an mesh type\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.StructuredMesh","page":"Meshes","title":"FiniteElementContainers.StructuredMesh","text":"struct StructuredMesh{ND, RT<:Number, IT<:Integer, EConns} <: FiniteElementContainers.AbstractMesh\n\nnodal_coords::H1Field{RT, Vector{RT}, ND} where {ND, RT<:Number}\nelement_block_names::Vector{Symbol}\nelement_types::Vector{Symbol}\nelement_conns::Any\nelement_id_maps::Dict{Symbol, Vector{IT}} where IT<:Integer\nnode_id_map::Vector{IT} where IT<:Integer\nnodeset_nodes::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_elems::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_nodes::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_sides::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_side_nodes::Dict{Symbol, Matrix{IT}} where IT<:Integer\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"struct UnstructuredMesh{MeshObj, ND, RT<:Number, IT<:Integer, EConns, EdgeConns, FaceConns} <: FiniteElementContainers.AbstractMesh\n\nmesh_obj::Any\nnodal_coords::H1Field{RT, Vector{RT}, ND} where {ND, RT<:Number}\nelement_block_names::Vector{Symbol}\nelement_types::Vector{Symbol}\nelement_conns::Any\nelement_id_maps::Dict{Symbol, Vector{IT}} where IT<:Integer\nnode_id_map::Vector{IT} where IT<:Integer\nnodeset_nodes::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_elems::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_nodes::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_sides::Dict{Symbol, Vector{IT}} where IT<:Integer\nsideset_side_nodes::Dict{Symbol, Matrix{IT}} where IT<:Integer\nedge_conns::Any\nface_conns::Any\n\n\n\n\n\n","category":"type"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Tuple{FiniteElementContainers.AbstractMeshType, String, Bool, Bool}","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file_type::FiniteElementContainers.AbstractMeshType,\n    file_name::String,\n    create_edges::Bool,\n    create_faces::Bool\n) -> UnstructuredMesh{MeshObj, ND, RT, IT, EConns, EdgeConns, Nothing} where {MeshObj, ND, RT<:Number, IT<:Integer, EConns, EdgeConns}\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Tuple{String}","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file_name::String;\n    create_edges,\n    create_faces\n) -> UnstructuredMesh{MeshObj, ND, RT, IT, EConns, EdgeConns, Nothing} where {MeshObj, ND, RT<:Number, IT<:Integer, EConns, EdgeConns}\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.UnstructuredMesh-Union{Tuple{T}, Tuple{FileMesh{T}, Bool, Bool}} where T","page":"Meshes","title":"FiniteElementContainers.UnstructuredMesh","text":"UnstructuredMesh(\n    file::FileMesh{T},\n    create_edges::Bool,\n    create_faces::Bool\n) -> UnstructuredMesh{MeshObj, ND, RT, IT, EConns, EdgeConns, Nothing} where {MeshObj, ND, RT<:Number, IT<:Integer, EConns, EdgeConns}\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.FileMesh-Tuple{FiniteElementContainers.ExodusMesh, String}","page":"Meshes","title":"FiniteElementContainers.FileMesh","text":"struct FileMesh{MeshObj} <: FiniteElementContainers.AbstractMesh\n\nfile_name::String\nmesh_obj::Any\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.coordinates-Union{Tuple{FileMesh{Exodus.ExodusDatabase{M, I, B, F}}}, Tuple{F}, Tuple{B}, Tuple{I}, Tuple{M}} where {M, I, B, F}","page":"Meshes","title":"FiniteElementContainers.coordinates","text":"coordinates(\n    mesh::FileMesh{Exodus.ExodusDatabase{M, I, B, F}}\n) -> Matrix\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_id_map-Tuple{FileMesh{<:Exodus.ExodusDatabase}, Any}","page":"Meshes","title":"FiniteElementContainers.element_block_id_map","text":"element_block_id_map(\n    mesh::FileMesh{<:Exodus.ExodusDatabase},\n    id\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_ids-Tuple{FileMesh{<:Exodus.ExodusDatabase}}","page":"Meshes","title":"FiniteElementContainers.element_block_ids","text":"element_block_ids(\n    mesh::FileMesh{<:Exodus.ExodusDatabase}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.element_block_names-Tuple{FileMesh{<:Exodus.ExodusDatabase}}","page":"Meshes","title":"FiniteElementContainers.element_block_names","text":"element_block_names(\n    mesh::FileMesh{<:Exodus.ExodusDatabase}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.node_cmaps-Tuple{FileMesh{<:Exodus.ExodusDatabase}, Any}","page":"Meshes","title":"FiniteElementContainers.node_cmaps","text":"node_cmaps(\n    mesh::FileMesh{<:Exodus.ExodusDatabase},\n    rank\n) -> Vector\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset_ids-Tuple{FileMesh{<:Exodus.ExodusDatabase}}","page":"Meshes","title":"FiniteElementContainers.nodeset_ids","text":"nodeset_ids(mesh::FileMesh{<:Exodus.ExodusDatabase}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.nodeset_names-Tuple{FileMesh{<:Exodus.ExodusDatabase}}","page":"Meshes","title":"FiniteElementContainers.nodeset_names","text":"nodeset_names(\n    mesh::FileMesh{<:Exodus.ExodusDatabase}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset_ids-Tuple{FileMesh{<:Exodus.ExodusDatabase}}","page":"Meshes","title":"FiniteElementContainers.sideset_ids","text":"sideset_ids(mesh::FileMesh{<:Exodus.ExodusDatabase}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"meshes/#FiniteElementContainers.sideset_names-Tuple{FileMesh{<:Exodus.ExodusDatabase}}","page":"Meshes","title":"FiniteElementContainers.sideset_names","text":"sideset_names(\n    mesh::FileMesh{<:Exodus.ExodusDatabase}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#Fields","page":"Fields","title":"Fields","text":"Fields serve as loose wrappers around AbstractArray subtypes such that the size of array slices are known at compile time. Although this introduces a type-instability, the idea is to do this at the top most level (mainly at setup time of a FEM simulation). By introducing this type instability, we can gain information about the field type that is used in methods downstream to construct StaticArrays of views of field types.\n\nAll fields are subtypes of the abstract type AbstractField\n\nusing FiniteElementContainers\nFiniteElementContainers.AbstractField","category":"section"},{"location":"fields/#Example-H1Field-a.k.a.-NodalField","page":"Fields","title":"Example - H1Field a.k.a. NodalField","text":"We can set up a H1Field in one of two ways. The simplest constructor form can be used as follows\n\nusing FiniteElementContainers\nfield = H1Field(rand(2, 10))\n\nThis is stored in a vectorized way as can be seen above\n\nfield.data\n\nFields can be indexed like regular arrays, e.g.\n\nfield[1, 1]\n\nfield[1, :]\n\netc.","category":"section"},{"location":"fields/#Abstract-type","page":"Fields","title":"Abstract type","text":"The base type for fields is the AbstractField abstract type. \n\nAny new field added to FiniteElementContainers should be a subtype of this type.","category":"section"},{"location":"fields/#Methods-for-AbstractField","page":"Fields","title":"Methods for AbstractField","text":"","category":"section"},{"location":"fields/#Implementations","page":"Fields","title":"Implementations","text":"The existing direct subtypes of AbstractField are the following","category":"section"},{"location":"fields/#Connectivity","page":"Fields","title":"Connectivity","text":"The connectivity type is a simple alias for L2ElementField defined below","category":"section"},{"location":"fields/#H1-field","page":"Fields","title":"H1 field","text":"","category":"section"},{"location":"fields/#L2Element-field","page":"Fields","title":"L2Element field","text":"","category":"section"},{"location":"fields/#L2Quadrature-field","page":"Fields","title":"L2Quadrature field","text":"There are plans to add HcurlField and HdivField types as well","category":"section"},{"location":"fields/#FiniteElementContainers.AbstractField","page":"Fields","title":"FiniteElementContainers.AbstractField","text":"abstract type AbstractField{T, N, D<:AbstractArray{T, 1}, NF} <: AbstractArray{T, N}\n\nThin wrapper that subtypes AbstractArray and serves as the base Field type\n\n\n\n\n\n","category":"type"},{"location":"fields/#Base.fill!-Union{Tuple{NF}, Tuple{D}, Tuple{N}, Tuple{T}, Tuple{FiniteElementContainers.AbstractField{T, N, D, NF}, T}} where {T, N, D, NF}","page":"Fields","title":"Base.fill!","text":"fill!(\n    field::FiniteElementContainers.AbstractField{T, N, D, NF},\n    v\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_fields-Union{Tuple{FiniteElementContainers.AbstractField{T, N, D, NF}}, Tuple{NF}, Tuple{D}, Tuple{N}, Tuple{T}} where {T, N, D, NF}","page":"Fields","title":"FiniteElementContainers.num_fields","text":"num_fields(\n    _::FiniteElementContainers.AbstractField{T, N, D, NF}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#KernelAbstractions.get_backend-Tuple{FiniteElementContainers.AbstractField}","page":"Fields","title":"KernelAbstractions.get_backend","text":"get_backend(\n    field::FiniteElementContainers.AbstractField\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.Connectivity","page":"Fields","title":"FiniteElementContainers.Connectivity","text":"struct L2ElementField{T, D, NF} <: FiniteElementContainers.AbstractField{T, 2, D, NF}\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.connectivity-Tuple{L2ElementField, Int64}","page":"Fields","title":"FiniteElementContainers.connectivity","text":"connectivity(\n    conn::L2ElementField,\n    e::Int64\n) -> SubArray{T, 1} where T\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.connectivity-Tuple{L2ElementField}","page":"Fields","title":"FiniteElementContainers.connectivity","text":"connectivity(conn::L2ElementField) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.H1Field","page":"Fields","title":"FiniteElementContainers.H1Field","text":"struct H1Field{T, D, NF} <: FiniteElementContainers.AbstractField{T, 2, D, NF}\n\nImplementation of fields that live on nodes.\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.H1Field-Tuple{M} where M<:(AbstractMatrix)","page":"Fields","title":"FiniteElementContainers.H1Field","text":"H1Field(data::AbstractMatrix) -> H1Field\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_nodes-Union{Tuple{H1Field{T, D, NF}}, Tuple{NF}, Tuple{D}, Tuple{T}} where {T, D, NF}","page":"Fields","title":"FiniteElementContainers.num_nodes","text":"num_nodes(field::H1Field{T, D, NF}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.L2ElementField","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"struct L2ElementField{T, D, NF} <: FiniteElementContainers.AbstractField{T, 2, D, NF}\n\nImplementation of fields that live on elements.\n\n\n\n\n\n","category":"type"},{"location":"fields/#FiniteElementContainers.L2ElementField-Tuple{M} where M<:(AbstractMatrix)","page":"Fields","title":"FiniteElementContainers.L2ElementField","text":"L2ElementField(data::AbstractMatrix) -> L2ElementField\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_elements-Union{Tuple{L2ElementField{T, D, NF}}, Tuple{NF}, Tuple{D}, Tuple{T}} where {T, D, NF}","page":"Fields","title":"FiniteElementContainers.num_elements","text":"num_elements(field::L2ElementField{T, D, NF}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.num_nodes_per_element-Tuple{L2ElementField}","page":"Fields","title":"FiniteElementContainers.num_nodes_per_element","text":"num_nodes_per_element(field::L2ElementField) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"fields/#FiniteElementContainers.L2QuadratureField","page":"Fields","title":"FiniteElementContainers.L2QuadratureField","text":"struct L2QuadratureField{T, D, NF, NQ} <: FiniteElementContainers.AbstractField{T, 3, D, NF}\n\nImplementation of fields that live on elements.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/2_advection_diffusion_equation/#2.-Advection-Diffusion-Equation","page":"2 Advection-Diffusion Equation","title":"2. Advection-Diffusion Equation","text":"This example mimics the second Moose tutorial.","category":"section"},{"location":"tutorials/2_advection_diffusion_equation/#Strong-Form","page":"2 Advection-Diffusion Equation","title":"Strong Form","text":"Consider the advection equation on a domain Omega subset mathbbR^d with boundary partial Omega:\n\n-nabla cdot nabla u + mathbfvcdotnabla u = 0 quad textin  Omega\n\nwith Dirichlet boundary conditions\n\nu = g quad texton  partial Omega_D\n\nand Neumann boundary conditions\n\nnabla u cdot n = h quad texton  partial Omega_N\n\nwhere n is the outward normal vector on the boundary.","category":"section"},{"location":"tutorials/2_advection_diffusion_equation/#Weak-Form","page":"2 Advection-Diffusion Equation","title":"Weak Form","text":"To derive the weak form, multiply the PDE by a test function w in V_0 which is zero on ( partial Omega_D ) and integrated over Omega:\n\n-int_Omega v  (nabla cdot nabla u)  dOmega + int_Omega v  (mathbfv cdot nabla u)  dOmega = 0\n\nApplying integration by parts to the left-hand side:\n\nint_Omega nabla v cdot nabla u  dOmega - int_partial Omega v  (nabla u cdot n)  dGamma + int_Omega v  (mathbfv cdot nabla u)  dOmega = 0\n\nUsing the boundary conditions:\n\nint_Omega nabla v cdot nabla u  dOmega + int_Omega v  (mathbfv cdot nabla u)  dOmega = int_partial Omega_N v  h  dGamma","category":"section"},{"location":"tutorials/2_advection_diffusion_equation/#Implementation","page":"2 Advection-Diffusion Equation","title":"Implementation","text":"struct AdvectionDiffusion{N} <: AbstractPhysics{1, 0, 0}\n    v::SVector{N, Float64}\nend\n\n@inline function FiniteElementContainers.residual(\n    physics::AdvectionDiffusion, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n    interps = map_interpolants(interps, x_el)\n    (; X_q, N, ∇N_X, JxW) = interps\n    ∇u_q = interpolate_field_gradients(physics, interps, u_el)\n    ∇u_q = unpack_field(∇u_q, 1)\n    term = dot(∇u_q, physics.v)\n    R_q = ∇N_X * ∇u_q + term * N\n    return JxW * R_q[:]\nend\n  \n@inline function FiniteElementContainers.stiffness(\n    physics::AdvectionDiffusion, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n    interps = map_interpolants(interps, x_el)\n    (; X_q, N, ∇N_X, JxW) = interps\n    term = ∇N_X * physics.v\n    K_q = ∇N_X * ∇N_X' + N * term'\n    return JxW * K_q\nend\n\nIn the above we gave our new type AdvectionDiffusion a generic type parameter N so it can work for 1D, 2D, or 3D problems. It has a single field, the velocity which we could have made a property but since it is constant everywhere, we can just pack it in the type. This physics type has one field and no properties or state variables. The residual and stiffness methods are analogous to the previous example.","category":"section"},{"location":"tutorials/2_advection_diffusion_equation/#Three-dimensional-problem","page":"2 Advection-Diffusion Equation","title":"Three dimensional problem","text":"using FiniteElementContainers\nusing StaticArrays\n\n# setup some helper functions for f and the bcs rhs\nf(_, _) = 0.0\none_func(_, _) = 1.0\nzero_func(_, _) = 0.0\n\nmesh_file = \"mug.e\"\nmesh = UnstructuredMesh(mesh_file)\nV = FunctionSpace(mesh, H1Field, Lagrange) \nphysics = AdvectionDiffusion(SVector{2, Float64}(0., 0., 1.))\nprops = create_properties(physics)\nu = ScalarFunction(V, :u)\nasm = SparseMatrixAssembler(u; use_condensed=use_condensed)\n\n# setup bcs\ndbcs = [\n    DirichletBC(:u, one_func; sideset_name = :bottom)\n    DirichletBC(:u, zero_func; sideset_name = :top)\n]\n# setup the parameters\np = create_parameters(mesh, asm, physics, props; dirichlet_bcs=dbcs)\n\n# setup a solver\nsolver = NewtonSolver(DirectLinearSolver(asm))\n\n# setup an integrator and let it all evolve one time step\nintegrator = QuasiStaticIntegrator(solver)\nevolve!(integrator, p)\n\n# grab our full solution field from our parameters\nU = p.h1_field\n\n# post process results to exodus file\noutput_file = \"my_output.exo\"\npp = PostProcessor(mesh, output_file, u)\nwrite_times(pp, 1, 0.0)\nwrite_field(pp, 1, (\"u\",), U)\nclose(pp)\n\n(Image: )","category":"section"},{"location":"tutorials/1_poisson_equation/#1.-Poisson-Equation","page":"1 Poisson Equation","title":"1. Poisson Equation","text":"","category":"section"},{"location":"tutorials/1_poisson_equation/#Strong-Form","page":"1 Poisson Equation","title":"Strong Form","text":"Consider the Poisson equation on a domain Omega subset mathbbR^d with boundary partial Omega:\n\n-nabla cdot nabla u = f quad textin  Omega\n\nwith Dirichlet boundary conditions\n\nu = g quad texton  partial Omega_D\n\nand Neumann boundary conditions\n\nnabla u cdot n = h quad texton  partial Omega_N\n\nwhere f is a source term, and n is the outward normal vector on the boundary.","category":"section"},{"location":"tutorials/1_poisson_equation/#Weak-Form","page":"1 Poisson Equation","title":"Weak Form","text":"To derive the weak form, multiply the PDE by a test function w in V_0 which is zero on ( partial Omega_D ) and integrated over Omega:\n\n-int_Omega v  (nabla cdot nabla u)  dOmega = int_Omega v  f  dOmega\n\nApplying integration by parts to the left-hand side:\n\nint_Omega nabla v cdot nabla u  dOmega - int_partial Omega v  (nabla u cdot n)  dGamma = int_Omega v  f  dOmega\n\nUsing the boundary conditions:\n\nint_Omega nabla v cdot nabla u  dOmega = int_Omega v  f  dOmega + int_partial Omega_N v  h  dGamma","category":"section"},{"location":"tutorials/1_poisson_equation/#Finite-Element-Formulation","page":"1 Poisson Equation","title":"Finite Element Formulation","text":"Let V_h subset V be a finite-dimensional space of trial functions and test functions. The discrete weak form is:\n\ntextFind  u_h in V_h text such that   int_Omega nabla v_h cdot nabla u_h  dOmega = int_Omega v_h  f  dOmega + int_partial Omega_N v_h  h  dGamma quad forall v_h in V_h","category":"section"},{"location":"tutorials/1_poisson_equation/#Shape-function-values","page":"1 Poisson Equation","title":"Shape function values","text":"Each element Omega_e is mapped to a reference element hatOmega via a geometric mapping:\n\nx(hatxi) = sum_i=1^n_textnodes N_i(hatxi)  x_i\n\nwhere:\n\nN_i(hatxi) are the shape functions on the reference element  \nx_i are the physical node coordinates  \nhatxi in hatOmega is the reference coordinate  \n\nNOTE: All of this is handled internally. The user does not need to implement this. This is just shown for completeness for those not familiar with the nuts and bolts of the finite element method.","category":"section"},{"location":"tutorials/1_poisson_equation/#Shape-function-gradients","page":"1 Poisson Equation","title":"Shape function gradients","text":"To compute nabla u_h in the physical element, we use the chain rule:\n\nnabla u_h(x) = sum_i=1^n_textnodes u_i  nabla N_i(x) = sum_i=1^n_textnodes u_i  J^-T  hatnabla N_i(hatxi)\n\nwhere:\n\nhatnabla N_i(hatxi) are gradients in the reference element  \nJ is the Jacobian matrix of the mapping:\n\nJ = fracpartial xpartial hatxi = sum_i=1^n_textnodes x_i  hatnabla N_i(hatxi)^T\n\nJ^-T maps reference gradients to physical gradients.  \n\nThe determinant of the Jacobian, J, scales the quadrature weights when integrating:\n\nNOTE: All of this is handled internally. The user does not need to implement this. This is just shown for completeness for those not familiar with the nuts and bolts of the finite element method.Shape function values","category":"section"},{"location":"tutorials/1_poisson_equation/#Element-wise-Assembly-with-Quadrature","page":"1 Poisson Equation","title":"Element-wise Assembly with Quadrature","text":"The domain Omega is divided into finite elements Omega_e, and the integrals are computed element-wise:\n\nint_Omega nabla v_h cdot nabla u_h  dOmega = sum_e int_Omega_e nabla v_h cdot nabla u_h  dOmega\n\nEach element integral is approximated using quadrature:\n\nint_Omega_e nabla v_h cdot nabla u_h  dOmega approx sum_q=1^N_q w_q  J(hatxi_q) (nabla v_h(x(hatxi_q)) cdot nabla u_h(x(hatxi_q)))\n\nwhere:\n\nx_q are the quadrature points in the element Omega_e  \nw_q are the associated quadrature weights  \nN_q is the number of quadrature points in the element  ","category":"section"},{"location":"tutorials/1_poisson_equation/#Implementation","page":"1 Poisson Equation","title":"Implementation","text":"Currently, FiniteElementContainers expects a set of functions that can be provided to the assemblers that represent concepts such as energies, residuals (gradients), and stiffnesses (hessians). Below is an implementation of the above Galerkin finite element formulation in forms suitable to work with the rest of the FiniteElementContainers machinary.  These methods will works on all currently tested backends (e.g. CPU, CUDA, and RocM).\n\nWe can take the above equation and represent a discrete residual equation\n\nR_a = int_Omega nabla N^a cdot nabla u^a  dOmega - int_Omega N^a  f  dOmega - int_partial Omega_N N^a  h  dGamma than a suitable tangent (stiffness, or whatever you prefer to call it) for a Newton type method is the following\n\nK_ab = fracpartial R_apartial u_b = int_Omega nabla N^a cdot nabla N^b dOmega\n\nFirst we need to create a type for our new physics. We do this by creating a subtype of AbstractPhysics as follows\n\nstruct Poisson{F <: Function} <: AbstractPhysics{1, 0, 0}\n  func::F\nend\n\nIn the above we create a new type called Poisson that has a single field, our driving function f. This type is a subtype of AbstractPhysics which has three required generic fields, the number of fields per entity (e.g. node, face, etc.) in the physics (here 1), the number of properties per element, and the number of state variables per quadrature point. For the simple case of a Poisson equation we do not have properties or state variables so these are simply zero. We will explore examples of physical models that require properties and state variables in future tutorials.\n\nNow that we have a type associated with our physics, we can implement the necessary methods for our example. We need a residual method and a stiffness method.\n\nLet's start with the residual method.\n\n@inline function FiniteElementContainers.residual(\n  physics::Poisson, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n  interps = map_interpolants(interps, x_el)\n  (; X_q, N, ∇N_X, JxW) = interps\n  ∇u_q = interpolate_field_gradients(physics, interps, u_el)\n  R_q = ∇u_q * ∇N_X' - N' * physics.func(X_q, 0.0)\n  return JxW * R_q[:]\nend\n\nLet's now unpack what probably looks like a fairly complex method at first glance, especially for such a simple equation. \n\nThe @inline macro is required to ensure this runs on GPU backends. Without this you'll likely run into hard to debug GPU errors that may differ from device to device. The first argument to the method is our physics type we defined above. \nThe second argument is a set of interpolation function values, gradients, and hessians for the reference element of a given block. Note that this method is defined in a such a way that it is element agnostic and operates on a single quadrature point. So the interps input is a set of shape function values, gradients, hessians, etc. for a given quadrature points. - The next three inputs are the element level coordinates x_el, the current time t, and the current time step dt. \nThe next two inputs are the current and old element level solution fields u_el and u_el_old. \nThese are followed by the quadrature level current and old state variables state_old_q and state_new_q and the element level properties props_el. A lot of these fields are completely unnecessary for a problem as simple as the Poisson equation, but they will reveal their usefulness in more compex tutorials. They are required for all physics so we do not need to write a bunch of duplicated assembly methods. Working with varargs on potentially different types on GPUs can be tricky.\n\nNow let's walk through the actual method body. The first two lines\n\ninterps = map_interpolants(interps, x_el)\n(; X_q, N, ∇N_X, JxW) = interps\n\nmaps the quadrature level shape function values, and gradients to the current element configuration and unpacks the mapped interpolants. X_q is the quadrature point coordinates in the physical space, N is the shape function value, ∇N_X is the shape function gradient in the physical space, and JxW is the determinant of the mapping Jacobian times the Guass quadrature weight.\n\nThe next line calls a helper method\n\n∇u_q = interpolate_field_gradients(physics, interps, u_el)\n\nwhich uses the shape function gradients and the element level solution field to calculate the quadrature level solution field gradient. \n\nFinally, in the last two lines we compute the residual, integrate it, and return to the calling method.\n\nR_q = ∇u_q * ∇N_X' - N' * physics.func(X_q, 0.0)\nreturn JxW * R_q[:]\n\nFor the stiffness method we can define this analytically as\n\n@inline function FiniteElementContainers.stiffness(\n  physics::Poisson, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el\n)\n  interps = map_interpolants(interps, x_el)\n  (; X_q, N, ∇N_X, JxW) = interps\n  K_q = ∇N_X * ∇N_X'\n  return JxW * K_q\nend\n\nor we could use an AD engine if we're feeling lazy.\n\nWith these two methods, we have everything we need to assemble the residual and stiffness matrix necessary for a standard Newton method. ","category":"section"},{"location":"tutorials/1_poisson_equation/#Two-dimensional-problem-Poisson-on-a-square","page":"1 Poisson Equation","title":"Two-dimensional problem - Poisson on a square","text":"Let's now solve an actual problem with the methods defined above. Rolling together a simple problem is very straightforward in FiniteElementContainers.jl and can be achieved in very little code.\n\nBelow is an actual example of a homogenous Dirichlet problem on a square. We will use the following forcing function \n\nf(x y) = 2π^2 sin(πx) sin(πy)\n\nusing FiniteElementContainers\n\n# setup some helper functions for f and the bcs rhs\nf(X, _) = 2. * π^2 * sin(π * X[1]) * sin(π * X[2])\nbc_func(_, _) = 0.\n\nmesh_file = \"my_mesh.exo\"\nmesh = UnstructuredMesh(mesh_file)\nV = FunctionSpace(mesh, H1Field, Lagrange) \nphysics = Poisson(f)\nprops = create_properties(physics)\nu = ScalarFunction(V, :u)\nasm = SparseMatrixAssembler(u; use_condensed=use_condensed)\n\n# setup bcs\ndbcs = DirichletBC[\n    DirichletBC(:u, bc_func; nodeset_name = :nset_1),\n    DirichletBC(:u, bc_func; nodeset_name = :nset_2),\n    DirichletBC(:u, bc_func; nodeset_name = :nset_3),\n    DirichletBC(:u, bc_func; nodeset_name = :nset_4),\n]\n\n# setup the parameters\np = create_parameters(mesh, asm, physics, props; dirichlet_bcs=dbcs)\n\n# setup a solver\nsolver = NewtonSolver(DirectLinearSolver(asm))\n\n# setup an integrator and let it all evolve one time step\nintegrator = QuasiStaticIntegrator(solver)\nevolve!(integrator, p)\n\n# grab our full solution field from our parameters\nU = p.h1_field\n\n# post process results to exodus file\noutput_file = \"my_output.exo\"\npp = PostProcessor(mesh, output_file, u)\nwrite_times(pp, 1, 0.0)\nwrite_field(pp, 1, (\"u\",), U)\nclose(pp)\n\nThis has the following visual solution\n\n(Image: )","category":"section"},{"location":"tutorials/1_poisson_equation/#Three-dimensional-Dirichlet-problem","page":"1 Poisson Equation","title":"Three dimensional Dirichlet problem","text":"Now let's look at another problem with same exact code but with a few modifications to boundary conditions, the forcing function, and the mesh file name. We're going to mimic the tutorial from the first tutorial from MOOSE\n\nusing FiniteElementContainers\n\n# setup some helper functions for f and the bcs rhs\nf(_, _) = 0.0\none_func(_, _) = 1.0\nzero_func(_, _) = 0.0\n\nmesh_file = \"mug.e\"\nmesh = UnstructuredMesh(mesh_file)\nV = FunctionSpace(mesh, H1Field, Lagrange) \nphysics = Poisson(f)\nprops = create_properties(physics)\nu = ScalarFunction(V, :u)\nasm = SparseMatrixAssembler(u; use_condensed=use_condensed)\n\n# setup bcs\ndbcs = [\n    DirichletBC(:u, one_func; sideset_name = :bottom)\n    DirichletBC(:u, zero_func; sideset_name = :top)\n]\n# setup the parameters\np = create_parameters(mesh, asm, physics, props; dirichlet_bcs=dbcs)\n\n# setup a solver\nsolver = NewtonSolver(DirectLinearSolver(asm))\n\n# setup an integrator and let it all evolve one time step\nintegrator = QuasiStaticIntegrator(solver)\nevolve!(integrator, p)\n\n# grab our full solution field from our parameters\nU = p.h1_field\n\n# post process results to exodus file\noutput_file = \"my_output.exo\"\npp = PostProcessor(mesh, output_file, u)\nwrite_times(pp, 1, 0.0)\nwrite_field(pp, 1, (\"u\",), U)\nclose(pp)\n\n(Image: )","category":"section"},{"location":"formulations/#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"formulations/#Implementations","page":"Formulations","title":"Implementations","text":"","category":"section"},{"location":"formulations/#Methods","page":"Formulations","title":"Methods","text":"","category":"section"},{"location":"formulations/#FiniteElementContainers.AbstractMechanicsFormulation","page":"Formulations","title":"FiniteElementContainers.AbstractMechanicsFormulation","text":"abstract type AbstractMechanicsFormulation{ND}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.IncompressiblePlaneStress","page":"Formulations","title":"FiniteElementContainers.IncompressiblePlaneStress","text":"struct IncompressiblePlaneStress <: AbstractMechanicsFormulation{2}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.PlaneStrain","page":"Formulations","title":"FiniteElementContainers.PlaneStrain","text":"struct PlaneStrain <: AbstractMechanicsFormulation{2}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.ScalarFormulation","page":"Formulations","title":"FiniteElementContainers.ScalarFormulation","text":"struct ScalarFormulation <: AbstractMechanicsFormulation{1}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.ThreeDimensional","page":"Formulations","title":"FiniteElementContainers.ThreeDimensional","text":"struct ThreeDimensional <: AbstractMechanicsFormulation{3}\n\n\n\n\n\n","category":"type"},{"location":"formulations/#FiniteElementContainers.discrete_gradient","page":"Formulations","title":"FiniteElementContainers.discrete_gradient","text":"discrete_gradient(_::IncompressiblePlaneStress, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::PlaneStrain, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::ScalarFormulation, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_gradient(_::ThreeDimensional, ∇N_X) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.discrete_symmetric_gradient","page":"Formulations","title":"FiniteElementContainers.discrete_symmetric_gradient","text":"discrete_symmetric_gradient(\n    _::IncompressiblePlaneStress,\n    ∇N_X\n) -> Any\n\n\n\n\n\n\ndiscrete_symmetric_gradient(_::PlaneStrain, ∇N_X) -> Any\n\n\n\n\n\n\ndiscrete_symmetric_gradient(_::ScalarFormulation, ∇N_X)\n\n\n\n\n\n\ndiscrete_symmetric_gradient(\n    _::ThreeDimensional,\n    ∇N_X\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.discrete_values","page":"Formulations","title":"FiniteElementContainers.discrete_values","text":"discrete_values(_::IncompressiblePlaneStress, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::PlaneStrain, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::ScalarFormulation, N) -> Any\n\n\n\n\n\n\ndiscrete_values(_::ThreeDimensional, N) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.extract_stiffness","page":"Formulations","title":"FiniteElementContainers.extract_stiffness","text":"extract_stiffness(\n    _::IncompressiblePlaneStress,\n    A::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stiffness(\n    _::PlaneStrain,\n    A::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stiffness(\n    _::ThreeDimensional,\n    A_in::Tensors.Tensor{4, 3, T<:Number, 81}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.extract_stress","page":"Formulations","title":"FiniteElementContainers.extract_stress","text":"extract_stress(\n    _::IncompressiblePlaneStress,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stress(\n    _::PlaneStrain,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\nextract_stress(\n    _::ThreeDimensional,\n    P::Tensors.Tensor{2, 3, T<:Number, 9}\n) -> StaticArraysCore.SArray\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.modify_field_gradients","page":"Formulations","title":"FiniteElementContainers.modify_field_gradients","text":"modify_field_gradients(\n    _::IncompressiblePlaneStress,\n    ∇u_q::StaticArraysCore.SArray{Tuple{2, 2}, T<:Number, 2, 4}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\nmodify_field_gradients(\n    _::PlaneStrain,\n    ∇u_q::StaticArraysCore.SArray{Tuple{2, 2}, T<:Number, 2, 4}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\nmodify_field_gradients(\n    _::ThreeDimensional,\n    ∇u_q::StaticArraysCore.SArray{Tuple{3, 3}, T<:Number, 2, 9}\n) -> Tensors.Tensor{2, 3, _A, 9} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"formulations/#FiniteElementContainers.num_dimensions","page":"Formulations","title":"FiniteElementContainers.num_dimensions","text":"num_dimensions(_::AbstractMechanicsFormulation{ND}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"physics/#FiniteElementContainers.create_properties-Union{Tuple{AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"FiniteElementContainers.create_properties","text":"create_properties(\n    physics::AbstractPhysics{NF, NP, NS}\n) -> StaticArraysCore.SVector{0, Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#FiniteElementContainers.reshape_element_level_coordinates-Union{Tuple{T}, Tuple{NxD}, Tuple{I}, Tuple{I, StaticArraysCore.SVector{NxD, T}}} where {I<:ReferenceFiniteElements.AbstractInterpolants, NxD, T<:Number}","page":"Physics","title":"FiniteElementContainers.reshape_element_level_coordinates","text":"reshape_element_level_coordinates(\n    interps::ReferenceFiniteElements.AbstractInterpolants,\n    x_el::StaticArraysCore.SArray{Tuple{NxD}, T<:Number, 1, NxD}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#FiniteElementContainers.reshape_element_level_field-Union{Tuple{T}, Tuple{NxNDof}, Tuple{P}, Tuple{P, StaticArraysCore.SVector{NxNDof, T}}} where {P<:AbstractPhysics, NxNDof, T<:Number}","page":"Physics","title":"FiniteElementContainers.reshape_element_level_field","text":"reshape_element_level_field(\n    physics::AbstractPhysics,\n    u_el::StaticArraysCore.SArray{Tuple{NxNDof}, T<:Number, 1, NxNDof}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#FiniteElementContainers.unpack_field-Union{Tuple{D}, Tuple{L}, Tuple{T}, Tuple{N}, Tuple{M}, Tuple{StaticArraysCore.SMatrix{M, N, T, L}, Int64, Int64, Val{D}}} where {M, N, T<:Number, L, D}","page":"Physics","title":"FiniteElementContainers.unpack_field","text":"unpack_field(\n    field::StaticArraysCore.SArray{Tuple{M, N}, T<:Number, 2, L},\n    dof_start::Int64,\n    dof_end::Int64,\n    _::Val{D}\n) -> Any\n\n\nUnpacks a range of fields values from a SMatrix. This is useful for extracting specific components from an interpolated field gradient at a quadrature point ∇u_q.\n\nreturns a SMatrix.\n\nNote the Val{D} that is a necessary input. This is crucial for performance with StaticArrays.\n\n\n\n\n\n","category":"method"},{"location":"physics/#FiniteElementContainers.unpack_field-Union{Tuple{L}, Tuple{T}, Tuple{N}, Tuple{M}, Tuple{StaticArraysCore.SMatrix{M, N, T, L}, Int64}} where {M, N, T<:Number, L}","page":"Physics","title":"FiniteElementContainers.unpack_field","text":"unpack_field(\n    field::StaticArraysCore.SArray{Tuple{M, N}, T<:Number, 2, L},\n    dof::Int64\n) -> Any\n\n\nUnpacks a single fields values from a SMatrix. This is useful for extracting specific components from an interpolated field gradient at a quadrature point ∇u_q.\n\nReturn a SVector\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#DofManager","page":"DofManager","title":"DofManager","text":"The DofManager is a struct that keeps track of which dofs are unknown or constrained. This can work with simple or mixed finite element spaces of various types. It is a glorified book keeper.\n\nA DofManager can be created as follows. First we must create functions for our variables of interest from their associated function spaces.\n\nusing Exodus, FiniteElementContainers\nmesh = UnstructuredMesh(\"../../test/poisson/poisson.g\")\nV = FunctionSpace(mesh, H1Field, Lagrange)\nu = VectorFunction(V, :u)\nt = ScalarFunction(V, :t)\nf = FiniteElementContainers.GeneralFunction(u, t)\n\nNow we can supply these variables to the DofManager which takes varargs as inputs\n\ndof = DofManager(f)\n\nThe print methods for this struct show simple metadata about the current dofs for each possible function space.\n\nA set of unknowns can be set up as follows\n\nfield = create_unknowns(dof)\n\nWe can create fields of the right size from the DofManager with the following methods\n\nfield = create_field(dof)\n\nThese methods take the backend of dof into account to ensure that the fields or unknowns produced are on the same device, e.g. CPU/GPU if dof is on the CPU/GPU.\n\nThis struct is created with all dofs initially set as unknown. To modify the unknowns we can do the following","category":"section"},{"location":"dof_manager/#API","page":"DofManager","title":"API","text":"","category":"section"},{"location":"dof_manager/#FiniteElementContainers.AbstractDofManager","page":"DofManager","title":"FiniteElementContainers.AbstractDofManager","text":"abstract type AbstractDofManager{IT<:Integer, IDs<:AbstractArray{IT<:Integer, 1}}\n\n\n\n\n\n","category":"type"},{"location":"dof_manager/#FiniteElementContainers.DofManager","page":"DofManager","title":"FiniteElementContainers.DofManager","text":"struct DofManager{Condensed, IT, IDs<:AbstractArray{IT, 1}, Var<:FiniteElementContainers.AbstractFunction} <: FiniteElementContainers.AbstractDofManager{IT, IDs<:AbstractArray{IT, 1}}\n\ndirichlet_dofs::AbstractVector\nunknown_dofs::AbstractVector\nvar::FiniteElementContainers.AbstractFunction\n\n\n\n\n\n","category":"type"},{"location":"dof_manager/#FiniteElementContainers.DofManager-Tuple{FiniteElementContainers.AbstractFunction}","page":"DofManager","title":"FiniteElementContainers.DofManager","text":"DofManager(\n    var::FiniteElementContainers.AbstractFunction;\n    use_condensed\n) -> DofManager{_A, Int64, Vector{Int64}, <:FiniteElementContainers.AbstractFunction{S, F}} where {_A, S, F<:FunctionSpace}\n\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#Base.length-Tuple{DofManager}","page":"DofManager","title":"Base.length","text":"length(dof::DofManager) -> Any\n\n\nReturn the total lenth of dofs in the problem.\n\nE.g. for an H1 space this will the number of nodes times the number of degrees of freedom per node.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#Base.size-Tuple{DofManager, Int64}","page":"DofManager","title":"Base.size","text":"size(dof::DofManager, i::Int64) -> Any\n\n\nsize(dof, 1) returns the number of dofs per entity, and size(dof, 2) returns the  number of entities.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#Base.size-Tuple{DofManager}","page":"DofManager","title":"Base.size","text":"size(dof::DofManager) -> Tuple{Any, Any}\n\n\nThis returns (n_dofs, n_entities) where n_dofs is the number of dofs per entity (e.g. node) and n_entities is the number of entitities (e.g. node).\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_field-Tuple{DofManager}","page":"DofManager","title":"FiniteElementContainers.create_field","text":"create_field(dof::DofManager) -> Any\n\n\nCreates a field where typeof(field) <: AbstractField based on the variable dof was created with\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_unknowns-Union{Tuple{DofManager{false, IT, IDs, Var}}, Tuple{Var}, Tuple{IDs}, Tuple{IT}} where {IT, IDs, Var}","page":"DofManager","title":"FiniteElementContainers.create_unknowns","text":"create_unknowns(dof::DofManager{false, IT, IDs, Var}) -> Any\n\n\nCreates a vector of unknown dofs.\n\nThis specific method returns a vector equal in length to the length of the internally stored list of unknown dofs in dof.\n\nThis is used for solution techniques when vector/matrix rows are removed where dofs are fixed.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.create_unknowns-Union{Tuple{DofManager{true, IT, IDs, Var}}, Tuple{Var}, Tuple{IDs}, Tuple{IT}} where {IT, IDs, Var}","page":"DofManager","title":"FiniteElementContainers.create_unknowns","text":"create_unknowns(dof::DofManager{true, IT, IDs, Var}) -> Any\n\n\nCreates a vector of unknown dofs.\n\nThis specific method returns a vector equal in length to the length of a field created by dof. E.g. all dofs are unknown.\n\nThis is used for solution techniques when vector/matrix rows are not  removed where dofs are fixed.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.extract_field_unknowns!-Union{Tuple{Var}, Tuple{IDs}, Tuple{IT}, Tuple{V}, Tuple{V, DofManager{false, IT, IDs, Var}, FiniteElementContainers.AbstractField}} where {V<:(AbstractVector{<:Number}), IT, IDs, Var}","page":"DofManager","title":"FiniteElementContainers.extract_field_unknowns!","text":"extract_field_unknowns!(\n    Uu::AbstractVector{<:Number},\n    dof::DofManager{false, IT, IDs, Var},\n    U::FiniteElementContainers.AbstractField\n)\n\n\nUpdates the entries of Uu with the unknown dofs in the field U.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_dofs!-Union{Tuple{V}, Tuple{DofManager, V}} where V<:(AbstractVector{<:Integer})","page":"DofManager","title":"FiniteElementContainers.update_dofs!","text":"update_dofs!(\n    dof::DofManager,\n    dirichlet_dofs::AbstractVector{<:Integer}\n)\n\n\nTakes in a list of dof ids associated with dirichlet bcs and updates the internals of dof to reflect these.\n\nNOTE: This clears all existing bcs in dof and starts fresh.\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_field_unknowns!-Union{Tuple{F}, Tuple{F, DofManager, F}} where F<:FiniteElementContainers.AbstractField","page":"DofManager","title":"FiniteElementContainers.update_field_unknowns!","text":"update_field_unknowns!(\n    U::FiniteElementContainers.AbstractField,\n    dof::DofManager,\n    Uu::FiniteElementContainers.AbstractField\n)\n\n\nTakes in a field and updates the field\n\nI think this one can be removed/deprecated\n\n\n\n\n\n","category":"method"},{"location":"dof_manager/#FiniteElementContainers.update_field_unknowns!-Union{Tuple{V}, Tuple{FiniteElementContainers.AbstractField, DofManager, V}} where V<:(AbstractVector{<:Number})","page":"DofManager","title":"FiniteElementContainers.update_field_unknowns!","text":"update_field_unknowns!(\n    U::FiniteElementContainers.AbstractField,\n    dof::DofManager,\n    Uu::AbstractVector{<:Number}\n)\n\n\nUpdates the unknowns of the field U based on  the values of Uu.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementContainers","page":"Home","title":"FiniteElementContainers","text":"FiniteElementContainers.jl is a package whose main purpose is to help  researchers develop new finite element method (FEM) applications for both well known existing techniques and new novel strategies.\n\nThis package is specificially designed with the challenging aspects of computational solid mechanics in mind where meshes deform, there's path dependence, there's contact between bodies, there are potentially heterogeneous material properties, and other challenges.\n\nIf you're primarily interested in writing FEM applications for e.g. the Poisson equation or heat equation, there's likely other FEM packages with less mental overhead out there for this purpose.\n\nHowever, if you need to solve problems with multiple material models, meshes where there are mixed elements types, etc. this is the package for you. \n\nInspiration for the software design primarily comes from fenics and MOOSE. We've specifically designed the interface to get around all the shortcomings of fenics  (e.g. boundary conditions are a pain, mixed element types are pain, different blocks are pain etc.) \n\nOur goal is also to ensure all of our methods are next generation hardware capable. This means not only supporting things on CPUs but also GPUs (and that doesn't just mean NVIDIA). The package is regularly tested against CUDA and RocM aware hardware to ensure all the types, methods, etc. work on CPUs and GPUs. Additionally, we test against Linux, MacOS, and Windows so in theory this should run on any personal computer out of the box. High performance computers are another story.","category":"section"}]
}
