<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Poisson Equation · FiniteElementContainers.jl</title><meta name="title" content="1 Poisson Equation · FiniteElementContainers.jl"/><meta property="og:title" content="1 Poisson Equation · FiniteElementContainers.jl"/><meta property="twitter:title" content="1 Poisson Equation · FiniteElementContainers.jl"/><meta name="description" content="Documentation for FiniteElementContainers.jl."/><meta property="og:description" content="Documentation for FiniteElementContainers.jl."/><meta property="twitter:description" content="Documentation for FiniteElementContainers.jl."/><meta property="og:url" content="https://cthonios.github.io/FiniteElementContainers.jl/tutorials/1_poisson_equation/"/><meta property="twitter:url" content="https://cthonios.github.io/FiniteElementContainers.jl/tutorials/1_poisson_equation/"/><link rel="canonical" href="https://cthonios.github.io/FiniteElementContainers.jl/tutorials/1_poisson_equation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FiniteElementContainers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li class="is-active"><a class="tocitem" href>1 Poisson Equation</a><ul class="internal"><li><a class="tocitem" href="#Strong-Form"><span>Strong Form</span></a></li><li><a class="tocitem" href="#Weak-Form"><span>Weak Form</span></a></li><li><a class="tocitem" href="#Finite-Element-Formulation"><span>Finite Element Formulation</span></a></li><li><a class="tocitem" href="#Shape-function-values"><span>Shape function values</span></a></li><li><a class="tocitem" href="#Shape-function-gradients"><span>Shape function gradients</span></a></li><li><a class="tocitem" href="#Element-wise-Assembly-with-Quadrature"><span>Element-wise Assembly with Quadrature</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Two-dimensional-problem-Poisson-on-a-square"><span>Two-dimensional problem - Poisson on a square</span></a></li><li class="toplevel"><a class="tocitem" href="#Three-dimensional-Dirichlet-problem"><span>Three dimensional Dirichlet problem</span></a></li></ul></li><li><a class="tocitem" href="../2_advection_diffusion_equation/">2 Advection-Diffusion Equation</a></li><li><a class="tocitem" href="../3_coupled_problem/">3 Coupled Problem</a></li><li><a class="tocitem" href="../4_transient_problem/">4 Transient Problem</a></li><li><a class="tocitem" href="../5_solid_mechanics/">5 Solid Mechanics</a></li></ul></li><li><a class="tocitem" href="../../assemblers/">Assemblers</a></li><li><a class="tocitem" href="../../boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../dof_manager/">DofManager</a></li><li><a class="tocitem" href="../../fields/">Fields</a></li><li><a class="tocitem" href="../../formulations/">Formulations</a></li><li><a class="tocitem" href="../../function_spaces/">Function spaces</a></li><li><a class="tocitem" href="../../functions/">Functions</a></li><li><a class="tocitem" href="../../meshes/">Meshes</a></li><li><a class="tocitem" href="../../parameters/">Parameters</a></li><li><a class="tocitem" href="../../physics/">Physics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>1 Poisson Equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1 Poisson Equation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Cthonios/FiniteElementContainers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Cthonios/FiniteElementContainers.jl/blob/main/docs/src/tutorials/1_poisson_equation.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="1.-Poisson-Equation"><a class="docs-heading-anchor" href="#1.-Poisson-Equation">1. Poisson Equation</a><a id="1.-Poisson-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Poisson-Equation" title="Permalink"></a></h1><h2 id="Strong-Form"><a class="docs-heading-anchor" href="#Strong-Form">Strong Form</a><a id="Strong-Form-1"></a><a class="docs-heading-anchor-permalink" href="#Strong-Form" title="Permalink"></a></h2><p>Consider the Poisson equation on a domain <span>$\Omega \subset \mathbb{R}^d$</span> with boundary <span>$\partial \Omega$</span>:</p><p><span>$-\nabla \cdot \nabla u = f \quad \text{in } \Omega,$</span></p><p>with Dirichlet boundary conditions</p><p><span>$u = g \quad \text{on } \partial \Omega_D,$</span></p><p>and Neumann boundary conditions</p><p><span>$\nabla u \cdot n = h \quad \text{on } \partial \Omega_N,$</span></p><p>where <span>$f$</span> is a source term, and <span>$n$</span> is the outward normal vector on the boundary.</p><h2 id="Weak-Form"><a class="docs-heading-anchor" href="#Weak-Form">Weak Form</a><a id="Weak-Form-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-Form" title="Permalink"></a></h2><p>To derive the weak form, multiply the PDE by a test function <span>$w \in V_0$</span> which is zero on <span>$( \partial \Omega_D )$</span> and integrated over <span>$\Omega$</span>:</p><p><span>$-\int_\Omega v \, (\nabla \cdot \nabla u) \, d\Omega = \int_\Omega v \, f \, d\Omega$</span></p><p>Applying integration by parts to the left-hand side:</p><p><span>$\int_\Omega \nabla v \cdot \nabla u \, d\Omega - \int_{\partial \Omega} v \, (\nabla u \cdot n) \, d\Gamma = \int_\Omega v \, f \, d\Omega$</span></p><p>Using the boundary conditions:</p><p><span>$\int_\Omega \nabla v \cdot \nabla u \, d\Omega = \int_\Omega v \, f \, d\Omega + \int_{\partial \Omega_N} v \, h \, d\Gamma$</span></p><h2 id="Finite-Element-Formulation"><a class="docs-heading-anchor" href="#Finite-Element-Formulation">Finite Element Formulation</a><a id="Finite-Element-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Element-Formulation" title="Permalink"></a></h2><p>Let <span>$V_h \subset V$</span> be a finite-dimensional space of trial functions and test functions. The discrete weak form is:</p><p><span>$\text{Find } u_h \in V_h \text{ such that }  \int_\Omega \nabla v_h \cdot \nabla u_h \, d\Omega = \int_\Omega v_h \, f \, d\Omega + \int_{\partial \Omega_N} v_h \, h \, d\Gamma \quad \forall v_h \in V_h.$</span></p><h2 id="Shape-function-values"><a class="docs-heading-anchor" href="#Shape-function-values">Shape function values</a><a id="Shape-function-values-1"></a><a class="docs-heading-anchor-permalink" href="#Shape-function-values" title="Permalink"></a></h2><p>Each element <span>$\Omega_e$</span> is mapped to a <strong>reference element</strong> <span>$\hat{\Omega}$</span> via a geometric mapping:</p><p><span>$x(\hat{\xi}) = \sum_{i=1}^{n_\text{nodes}} N_i(\hat{\xi}) \, x_i$</span></p><p>where:</p><ul><li><span>$N_i(\hat{\xi})$</span> are the <strong>shape functions</strong> on the reference element  </li><li><span>$x_i$</span> are the <strong>physical node coordinates</strong>  </li><li><span>$\hat{\xi} \in \hat{\Omega}$</span> is the reference coordinate  </li></ul><p>NOTE: All of this is handled internally. The user does not need to implement this. This is just shown for completeness for those not familiar with the nuts and bolts of the finite element method.</p><h2 id="Shape-function-gradients"><a class="docs-heading-anchor" href="#Shape-function-gradients">Shape function gradients</a><a id="Shape-function-gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Shape-function-gradients" title="Permalink"></a></h2><p>To compute <span>$\nabla u_h$</span> in the physical element, we use the chain rule:</p><p><span>$\nabla u_h(x) = \sum_{i=1}^{n_\text{nodes}} u_i \, \nabla N_i(x) = \sum_{i=1}^{n_\text{nodes}} u_i \, J^{-T} \, \hat{\nabla} N_i(\hat{\xi})$</span></p><p>where:</p><ul><li><span>$\hat{\nabla} N_i(\hat{\xi})$</span> are gradients in the reference element  </li><li><span>$J$</span> is the <strong>Jacobian matrix</strong> of the mapping:</li></ul><p><span>$J = \frac{\partial x}{\partial \hat{\xi}} = \sum_{i=1}^{n_\text{nodes}} x_i \, \hat{\nabla} N_i(\hat{\xi})^T$</span></p><ul><li><span>$J^{-T}$</span> maps reference gradients to physical gradients.  </li></ul><p>The determinant of the Jacobian, <span>$|J|$</span>, scales the quadrature weights when integrating:</p><p>NOTE: All of this is handled internally. The user does not need to implement this. This is just shown for completeness for those not familiar with the nuts and bolts of the finite element method.Shape function values</p><h2 id="Element-wise-Assembly-with-Quadrature"><a class="docs-heading-anchor" href="#Element-wise-Assembly-with-Quadrature">Element-wise Assembly with Quadrature</a><a id="Element-wise-Assembly-with-Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Element-wise-Assembly-with-Quadrature" title="Permalink"></a></h2><p>The domain <span>$\Omega$</span> is divided into finite elements <span>$\Omega_e$</span>, and the integrals are computed element-wise:</p><p><span>$\int_\Omega \nabla v_h \cdot \nabla u_h \, d\Omega = \sum_{e} \int_{\Omega_e} \nabla v_h \cdot \nabla u_h \, d\Omega$</span></p><p>Each element integral is approximated using quadrature:</p><p><span>$\int_{\Omega_e} \nabla v_h \cdot \nabla u_h \, d\Omega \approx \sum_{q=1}^{N_q} w_q \, |J(\hat{\xi}_q)| (\nabla v_h(x(\hat{\xi}_q)) \cdot \nabla u_h(x(\hat{\xi}_q)))$</span></p><p>where:</p><ul><li><span>$x_q$</span> are the quadrature points in the element <span>$\Omega_e$</span>  </li><li><span>$w_q$</span> are the associated quadrature weights  </li><li><span>$N_q$</span> is the number of quadrature points in the element  </li></ul><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>Currently, <code>FiniteElementContainers</code> expects a set of functions that can be provided to the assemblers that represent concepts such as energies, residuals (gradients), and stiffnesses (hessians). Below is an implementation of the above Galerkin finite element formulation in forms suitable to work with the rest of the <code>FiniteElementContainers</code> machinary.  These methods will works on all currently tested backends (e.g. CPU, CUDA, and RocM).</p><p>We can take the above equation and represent a discrete residual equation</p><p><span>$R_a = \int_\Omega \nabla N^a \cdot \nabla u^a \, d\Omega - \int_\Omega N^a \, f \, d\Omega - \int_{\partial \Omega_N} N^a \, h \, d\Gamma$</span> than a suitable tangent (stiffness, or whatever you prefer to call it) for a Newton type method is the following</p><p><span>$K_{ab} = \frac{\partial R_a}{\partial u_b} = \int_\Omega \nabla N^a \cdot \nabla N^b d\Omega$</span></p><p>First we need to create a type for our new physics. We do this by creating a subtype of <code>AbstractPhysics</code> as follows</p><pre><code class="language-julia hljs">struct Poisson{F &lt;: Function} &lt;: AbstractPhysics{1, 0, 0}
  func::F
end</code></pre><p>In the above we create a new type called <code>Poisson</code> that has a single field, our driving function <span>$f$</span>. This type is a subtype of <code>AbstractPhysics</code> which has three required generic fields, the number of fields per entity (e.g. node, face, etc.) in the physics (here 1), the number of properties per element, and the number of state variables per quadrature point. For the simple case of a Poisson equation we do not have properties or state variables so these are simply zero. We will explore examples of physical models that require properties and state variables in future tutorials.</p><p>Now that we have a type associated with our physics, we can implement the necessary methods for our example. We need a residual method and a stiffness method.</p><p>Let&#39;s start with the residual method.</p><pre><code class="language-julia hljs">@inline function FiniteElementContainers.residual(
  physics::Poisson, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el
)
  interps = map_interpolants(interps, x_el)
  (; X_q, N, ∇N_X, JxW) = interps
  ∇u_q = interpolate_field_gradients(physics, interps, u_el)
  R_q = ∇u_q * ∇N_X&#39; - N&#39; * physics.func(X_q, 0.0)
  return JxW * R_q[:]
end</code></pre><p>Let&#39;s now unpack what probably looks like a fairly complex method at first glance, especially for such a simple equation. </p><ul><li>The <code>@inline</code> macro is required to ensure this runs on GPU backends. Without this you&#39;ll likely run into hard to debug GPU errors that may differ from device to device. The first argument to the method is our physics type we defined above. </li><li>The second argument is a set of interpolation function values, gradients, and hessians for the reference element of a given block. Note that this method is defined in a such a way that it is element agnostic and operates on a single quadrature point. So the <code>interps</code> input is a set of shape function values, gradients, hessians, etc. for a given quadrature points. - The next three inputs are the element level coordinates <code>x_el</code>, the current time <code>t</code>, and the current time step <code>dt</code>. </li><li>The next two inputs are the current and old element level solution fields <code>u_el</code> and <code>u_el_old</code>. </li><li>These are followed by the quadrature level current and old state variables <code>state_old_q</code> and <code>state_new_q</code> and the element level properties <code>props_el</code>. A lot of these fields are completely unnecessary for a problem as simple as the Poisson equation, but they will reveal their usefulness in more compex tutorials. They are required for all physics so we do not need to write a bunch of duplicated assembly methods. Working with varargs on potentially different types on GPUs can be tricky.</li></ul><p>Now let&#39;s walk through the actual method body. The first two lines</p><pre><code class="language-julia hljs">interps = map_interpolants(interps, x_el)
(; X_q, N, ∇N_X, JxW) = interps</code></pre><p>maps the quadrature level shape function values, and gradients to the current element configuration and unpacks the mapped interpolants. <code>X_q</code> is the quadrature point coordinates in the physical space, <code>N</code> is the shape function value, <code>∇N_X</code> is the shape function gradient in the physical space, and <code>JxW</code> is the determinant of the mapping Jacobian times the Guass quadrature weight.</p><p>The next line calls a helper method</p><pre><code class="language-julia hljs">∇u_q = interpolate_field_gradients(physics, interps, u_el)</code></pre><p>which uses the shape function gradients and the element level solution field to calculate the quadrature level solution field gradient. </p><p>Finally, in the last two lines we compute the residual, integrate it, and return to the calling method.</p><pre><code class="language-julia hljs">R_q = ∇u_q * ∇N_X&#39; - N&#39; * physics.func(X_q, 0.0)
return JxW * R_q[:]</code></pre><p>For the stiffness method we can define this analytically as</p><pre><code class="language-julia hljs">@inline function FiniteElementContainers.stiffness(
  physics::Poisson, interps, x_el, t, dt, u_el, u_el_old, state_old_q, state_new_q, props_el
)
  interps = map_interpolants(interps, x_el)
  (; X_q, N, ∇N_X, JxW) = interps
  K_q = ∇N_X * ∇N_X&#39;
  return JxW * K_q
end</code></pre><p>or we could use an AD engine if we&#39;re feeling lazy.</p><p>With these two methods, we have everything we need to assemble the residual and stiffness matrix necessary for a standard Newton method. </p><h2 id="Two-dimensional-problem-Poisson-on-a-square"><a class="docs-heading-anchor" href="#Two-dimensional-problem-Poisson-on-a-square">Two-dimensional problem - Poisson on a square</a><a id="Two-dimensional-problem-Poisson-on-a-square-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-problem-Poisson-on-a-square" title="Permalink"></a></h2><p>Let&#39;s now solve an actual problem with the methods defined above. Rolling together a simple problem is very straightforward in <code>FiniteElementContainers.jl</code> and can be achieved in very little code.</p><p>Below is an actual example of a homogenous Dirichlet problem on a square. We will use the following forcing function </p><p><span>$f(x, y) = 2π^2 sin(πx) sin(πy)$</span></p><pre><code class="language-julia hljs">using FiniteElementContainers

# setup some helper functions for f and the bcs rhs
f(X, _) = 2. * π^2 * sin(π * X[1]) * sin(π * X[2])
bc_func(_, _) = 0.

mesh_file = &quot;my_mesh.exo&quot;
mesh = UnstructuredMesh(mesh_file)
V = FunctionSpace(mesh, H1Field, Lagrange) 
physics = Poisson(f)
props = create_properties(physics)
u = ScalarFunction(V, :u)
asm = SparseMatrixAssembler(u; use_condensed=use_condensed)

# setup bcs
dbcs = DirichletBC[
    DirichletBC(:u, bc_func; nodeset_name = :nset_1),
    DirichletBC(:u, bc_func; nodeset_name = :nset_2),
    DirichletBC(:u, bc_func; nodeset_name = :nset_3),
    DirichletBC(:u, bc_func; nodeset_name = :nset_4),
]

# setup the parameters
p = create_parameters(mesh, asm, physics, props; dirichlet_bcs=dbcs)

# setup a solver
solver = NewtonSolver(DirectLinearSolver(asm))

# setup an integrator and let it all evolve one time step
integrator = QuasiStaticIntegrator(solver)
evolve!(integrator, p)

# grab our full solution field from our parameters
U = p.h1_field

# post process results to exodus file
output_file = &quot;my_output.exo&quot;
pp = PostProcessor(mesh, output_file, u)
write_times(pp, 1, 0.0)
write_field(pp, 1, (&quot;u&quot;,), U)
close(pp)</code></pre><p>This has the following visual solution</p><p><img src="../assets/poisson_two_dimensional_dirichlet.png" alt/></p><h1 id="Three-dimensional-Dirichlet-problem"><a class="docs-heading-anchor" href="#Three-dimensional-Dirichlet-problem">Three dimensional Dirichlet problem</a><a id="Three-dimensional-Dirichlet-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Three-dimensional-Dirichlet-problem" title="Permalink"></a></h1><p>Now let&#39;s look at another problem with same exact code but with a few modifications to boundary conditions, the forcing function, and the mesh file name. We&#39;re going to mimic the tutorial from the first tutorial from <a href="https://mooseframework.inl.gov/getting_started/examples_and_tutorials/examples/ex01_inputfile.html">MOOSE</a></p><pre><code class="language-julia hljs">using FiniteElementContainers

# setup some helper functions for f and the bcs rhs
f(_, _) = 0.0
one_func(_, _) = 1.0
zero_func(_, _) = 0.0

mesh_file = &quot;mug.e&quot;
mesh = UnstructuredMesh(mesh_file)
V = FunctionSpace(mesh, H1Field, Lagrange) 
physics = Poisson(f)
props = create_properties(physics)
u = ScalarFunction(V, :u)
asm = SparseMatrixAssembler(u; use_condensed=use_condensed)

# setup bcs
dbcs = [
    DirichletBC(:u, one_func; sideset_name = :bottom)
    DirichletBC(:u, zero_func; sideset_name = :top)
]
# setup the parameters
p = create_parameters(mesh, asm, physics, props; dirichlet_bcs=dbcs)

# setup a solver
solver = NewtonSolver(DirectLinearSolver(asm))

# setup an integrator and let it all evolve one time step
integrator = QuasiStaticIntegrator(solver)
evolve!(integrator, p)

# grab our full solution field from our parameters
U = p.h1_field

# post process results to exodus file
output_file = &quot;my_output.exo&quot;
pp = PostProcessor(mesh, output_file, u)
write_times(pp, 1, 0.0)
write_field(pp, 1, (&quot;u&quot;,), U)
close(pp)</code></pre><p><img src="../assets/poisson_mug.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../2_advection_diffusion_equation/">2 Advection-Diffusion Equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 21 December 2025 00:45">Sunday 21 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
